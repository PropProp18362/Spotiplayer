<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpotiPlayer - Music Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --background: #050505;
      --text: #ffffff;
      --accent: #1DB954;
      --accent-hover: #1ED760;
      --surface: rgba(255, 255, 255, 0.05);
      --surface-hover: rgba(255, 255, 255, 0.1);
      --border: rgba(255, 255, 255, 0.1);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      --font-display: 'Space Grotesk', sans-serif;
      --font-body: 'Inter', sans-serif;
      --transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: var(--background);
      color: var(--text);
      font-family: var(--font-body);
      line-height: 1.6;
      overflow-x: hidden;
      min-height: 100vh;
      position: relative;
    }

    /* Canvas background */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.8;
    }

    /* App Header */
    .app-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px 40px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      background: rgba(5, 5, 5, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .logo-icon {
      color: var(--accent);
    }
    
    .logo-text {
      font-family: var(--font-display);
      font-weight: 700;
      font-size: 1.5rem;
      background: linear-gradient(90deg, var(--accent), #88f7b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-fill-color: transparent;
    }

    /* Landing Container */
    .landing-container {
      position: relative;
      z-index: 1;
      max-width: 1400px;
      margin: 0 auto;
      padding: 100px 40px 60px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Hero Section */
    .hero-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 60px;
      align-items: center;
      padding: 60px 0;
      min-height: 80vh;
    }

    .hero h1 {
      font-family: var(--font-display);
      font-size: clamp(2.5rem, 8vw, 5rem);
      font-weight: 700;
      line-height: 1.1;
      margin-bottom: 24px;
      position: relative;
    }

    .hero h1 .highlight {
      color: var(--accent);
      position: relative;
      display: inline-block;
    }

    .hero h1 .highlight::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: var(--accent);
      transform: scaleX(0);
      transform-origin: right;
      transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .hero h1:hover .highlight::after {
      transform: scaleX(1);
      transform-origin: left;
    }

    .hero p {
      font-size: clamp(1rem, 2vw, 1.25rem);
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
      margin-bottom: 40px;
    }

    /* Buttons */
    .button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 16px 32px;
      background: var(--accent);
      color: white;
      font-family: var(--font-display);
      font-weight: 600;
      font-size: 1rem;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      transition: var(--transition);
      text-decoration: none;
      position: relative;
      overflow: hidden;
    }

    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
      transform: translateX(-100%);
      transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .button:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
    }

    .button:hover::before {
      transform: translateX(100%);
    }

    .button svg {
      margin-right: 8px;
    }

    /* Features section */
    .features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 24px;
      margin-top: 80px;
    }

    .feature {
      background: var(--surface);
      border-radius: 16px;
      padding: 32px;
      border: 1px solid var(--border);
      transition: var(--transition);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .feature:hover {
      transform: translateY(-8px);
      background: var(--surface-hover);
      border-color: var(--accent);
    }

    .feature-icon {
      width: 48px;
      height: 48px;
      background: rgba(29, 185, 84, 0.1);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }

    .feature-icon svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
    }

    .feature h3 {
      font-family: var(--font-display);
      font-size: 1.25rem;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .feature p {
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
    }

    /* Cursor */
    .cursor {
      position: fixed;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid var(--accent);
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: width 0.3s, height 0.3s, border-color 0.3s;
      z-index: 9999;
      mix-blend-mode: difference;
    }

    .cursor-dot {
      position: fixed;
      width: 8px;
      height: 8px;
      background-color: var(--accent);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 9999;
      mix-blend-mode: difference;
    }

    /* Typing animation */
    .typing-container {
      display: inline-block;
      position: relative;
    }

    .typing-text {
      display: inline-block;
      color: var(--accent);
      position: relative;
    }

    .typing-cursor {
      display: inline-block;
      width: 3px;
      height: 1em;
      background-color: var(--accent);
      margin-left: 2px;
      animation: blink 1s infinite;
      vertical-align: text-bottom;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Debug panel */
    #debug-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      max-width: 400px;
      max-height: 300px;
      overflow: auto;
      z-index: 9999;
      font-family: monospace;
      font-size: 12px;
      color: var(--accent);
      display: none;
    }

    #debug-panel h3 {
      margin-bottom: 8px;
      font-size: 14px;
    }

    #debug-panel button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      margin-top: 8px;
      cursor: pointer;
    }

    /* Loading animation */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--accent);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Visualizer UI */
    .visualizer-ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100;
      display: none;
      overflow: hidden;
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    
    /* Page transitions */
    .landing-container, .app-header {
      transition: opacity 0.5s ease;
    }
    
    /* Sidebar */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 200;
      display: flex;
      flex-direction: column;
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
    }
    
    .sidebar.collapsed {
      transform: translateX(-100%);
    }
    
    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .sidebar-toggle {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    
    .sidebar-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .sidebar-section {
      margin-bottom: 30px;
    }
    
    .sidebar-title {
      font-family: var(--font-display);
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 15px;
      color: rgba(255, 255, 255, 0.8);
      position: relative;
      padding-bottom: 8px;
    }
    
    .sidebar-title::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 30px;
      height: 2px;
      background: var(--accent);
    }
    
    .visualization-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .viz-option {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      border-radius: 8px;
      padding: 12px 15px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .viz-option:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateX(5px);
    }
    
    .viz-option.active {
      background: rgba(29, 185, 84, 0.2);
      color: white;
      border-left: 3px solid var(--accent);
    }
    
    .viz-option.active svg {
      color: var(--accent);
    }
    
    .settings-list {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .setting-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .setting-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .setting-value {
      font-size: 12px;
      color: var(--accent);
      font-weight: 600;
    }
    
    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      transition: all 0.2s;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }
    
    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }
    
    .slider::-moz-range-thumb:hover {
      transform: scale(1.2);
    }
    
    .color-options {
      display: flex;
      gap: 10px;
    }
    
    .color-option {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .color-option.active {
      border-color: white;
      transform: scale(1.1);
    }
    
    .advanced-settings {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .setting-toggle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }
    
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .switch-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.1);
      transition: .4s;
      border-radius: 34px;
    }
    
    .switch-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .switch-slider {
      background-color: var(--accent);
    }
    
    input:checked + .switch-slider:before {
      transform: translateX(18px);
    }
    
    .sidebar-footer {
      padding: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .track-info-mini {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 15px;
    }
    
    .album-art-mini {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      object-fit: cover;
    }
    
    .track-details-mini {
      flex: 1;
      overflow: hidden;
    }
    
    .track-details-mini h4 {
      margin: 0 0 3px 0;
      font-size: 14px;
      font-weight: 600;
      color: white;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .track-details-mini p {
      margin: 0;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .disconnect-button {
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 10px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .disconnect-button:hover {
      background: rgba(255, 0, 0, 0.1);
      color: rgba(255, 100, 100, 0.9);
    }
    
    /* Main Visualizer Area */
    .visualizer-main {
      position: relative;
      width: 100%;
      height: 100%;
      padding-left: 300px;
      transition: padding-left 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }
    
    .sidebar.collapsed + .visualizer-main {
      padding-left: 0;
    }
    
    .track-info-overlay {
      position: absolute;
      top: 30px;
      left: 30px;
      max-width: 500px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .track-info-overlay.hidden {
      opacity: 0;
      transform: translateY(-20px);
      pointer-events: none;
    }
    
    .track-info-container {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    
    .album-art-large {
      width: 100px;
      height: 100px;
      border-radius: 8px;
      object-fit: cover;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    .track-details-large {
      flex: 1;
    }
    
    .track-details-large h2 {
      margin: 0 0 5px 0;
      font-size: 24px;
      font-weight: 700;
      color: white;
    }
    
    .track-details-large p {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .track-meta {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.6);
    }
    
    .meta-separator {
      margin: 0 8px;
    }
    
    .audio-info {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    
    .audio-feature {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .feature-label {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }
    
    .feature-value {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
    }
    
    .feature-bar-container {
      width: 100px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .feature-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
    }
    
    .visualizer-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 30px;
      padding: 10px 20px;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .control-button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    
    .control-button:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.1);
    }
    
    .viz-mode-indicator {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .fps-counter {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      padding: 5px 10px;
      font-size: 12px;
      color: var(--accent);
      font-family: monospace;
      display: none;
    }
    
    @keyframes pulse {
      0% { transform: scale(0.8); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(0.8); opacity: 0.8; }
    }
    
    /* Key Features */
    .key-features {
      display: flex;
      flex-direction: column;
      gap: 30px;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .key-feature {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 16px;
      padding: 30px;
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .key-feature:hover {
      background: rgba(255, 255, 255, 0.04);
      transform: translateX(10px);
    }
    
    .key-feature-icon {
      background: rgba(29, 185, 84, 0.1);
      min-width: 50px;
      height: 50px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
    }
    
    .key-feature-content h3 {
      font-family: var(--font-display);
      font-size: 1.3rem;
      margin-bottom: 10px;
    }
    
    .key-feature-content p {
      color: rgba(255, 255, 255, 0.7);
      font-size: 1rem;
      line-height: 1.6;
    }
    
    /* Redirect Notice */
    .redirect-notice {
      margin-top: 40px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      text-align: center;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    
    .redirect-notice strong {
      color: var(--accent);
    }
    
    .redirect-notice code {
      display: block;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      font-family: monospace;
      word-break: break-all;
    }
    
    .redirect-notice small {
      display: block;
      margin-top: 10px;
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Track notification */
    .track-notification {
      position: fixed;
      top: 30px;
      right: 30px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 12px;
      padding: 15px;
      z-index: 1000;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform: translateX(120%);
      transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      max-width: 350px;
    }
    
    .track-notification.show {
      transform: translateX(0);
    }
    
    .notification-content {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .notification-content img {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      object-fit: cover;
    }
    
    .notification-text p {
      margin: 0;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .notification-text p:first-child {
      color: var(--accent);
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .notification-text h4 {
      margin: 0 0 5px 0;
      font-size: 16px;
      font-weight: 600;
      color: white;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .hero {
        padding: 80px 0;
      }

      .features {
        grid-template-columns: 1fr;
      }

      .cursor, .cursor-dot {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Canvas background -->
  <canvas id="canvas"></canvas>

  <!-- Header -->
  <header class="app-header">
    <div class="logo">
      <svg class="logo-icon" width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM16.5 16.5C16.23 16.5 15.96 16.38 15.75 16.17C14.72 15.14 13.23 14.5 11.5 14.5C9.77 14.5 8.28 15.14 7.25 16.17C7.04 16.38 6.77 16.5 6.5 16.5C5.95 16.5 5.5 16.05 5.5 15.5C5.5 15.23 5.62 14.96 5.83 14.75C7.14 13.44 9.07 12.5 11.5 12.5C13.93 12.5 15.86 13.44 17.17 14.75C17.38 14.96 17.5 15.23 17.5 15.5C17.5 16.05 17.05 16.5 16.5 16.5ZM17.5 12C16.67 12 16 11.33 16 10.5C16 9.67 16.67 9 17.5 9C18.33 9 19 9.67 19 10.5C19 11.33 18.33 12 17.5 12ZM5.5 12C4.67 12 4 11.33 4 10.5C4 9.67 4.67 9 5.5 9C6.33 9 7 9.67 7 10.5C7 11.33 6.33 12 5.5 12Z" fill="currentColor"/>
      </svg>
      <span class="logo-text">SpotiViz</span>
    </div>
  </header>

  <!-- Main container -->
  <div class="landing-container">
    <div class="hero-section">
      <div class="hero-content">
        <h1 class="hero-title">
          <span class="hero-title-line">Transform your</span>
          <span class="hero-title-line">music into <span class="accent-text">visual art</span></span>
        </h1>
        <p class="hero-description">
          SpotiViz creates stunning real-time visualizations that respond to every beat, lyric, and mood of your Spotify music. Experience your favorite tracks in a completely new dimension.
        </p>
        <div class="cta-container">
          <button id="spotify-login" class="cta-button">
            <svg class="spotify-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M8 12.5a4.5 4.5 0 1 1 9 0"></path>
              <path d="M9.5 14.5c1.5-1 3.5-1 5 0"></path>
              <path d="M7 10.5c2.5-2 7.5-2 10 0"></path>
            </svg>
            Connect with Spotify
          </button>
          <div class="help-text">
            Having trouble? <a href="#" id="show-debug" class="text-link">Show debug info</a>
          </div>
        </div>
      </div>
      <div class="hero-visual">
        <div class="preview-container">
          <div class="preview-screen">
            <div class="preview-visualization"></div>
            <div class="preview-overlay"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="features-section">
      <h2 class="section-title">Visualization Modes</h2>
      <div class="features-grid">
        <div class="feature-card">
          <div class="feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="4" y="4" width="16" height="16" rx="2"></rect>
              <rect x="9" y="9" width="6" height="6"></rect>
              <path d="M15 4v16"></path>
              <path d="M4 15h16"></path>
            </svg>
          </div>
          <h3 class="feature-title">Spectrum</h3>
          <p class="feature-description">Advanced frequency spectrum with bass, mid, and treble separation that pulses with your music.</p>
        </div>
        <div class="feature-card">
          <div class="feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="4"></circle>
              <path d="M12 12h.01"></path>
            </svg>
          </div>
          <h3 class="feature-title">Orbital</h3>
          <p class="feature-description">3D orbital visualization with particles that orbit and react to the energy and mood of your tracks.</p>
        </div>
        <div class="feature-card">
          <div class="feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 3a9 9 0 0 0-9 9"></path>
              <path d="M12 21a9 9 0 0 0 0-18"></path>
              <path d="M21 12a9 9 0 0 0-9-9"></path>
              <path d="M9 21a9 9 0 0 1 0-18"></path>
              <path d="M12 12h.01"></path>
            </svg>
          </div>
          <h3 class="feature-title">Nebula</h3>
          <p class="feature-description">Fluid particle system that creates cosmic nebula-like patterns synchronized to your music.</p>
        </div>
        <div class="feature-card">
          <div class="feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M2 12h20"></path>
              <path d="M7 5c-.7 1.5-.7 3.5 0 5"></path>
              <path d="M17 5c.7 1.5.7 3.5 0 5"></path>
              <path d="M7 19c-.7-1.5-.7-3.5 0-5"></path>
              <path d="M17 19c.7-1.5.7-3.5 0-5"></path>
            </svg>
          </div>
          <h3 class="feature-title">Terrain</h3>
          <p class="feature-description">Dynamic 3D terrain that morphs and evolves with the intensity and rhythm of your music.</p>
        </div>
      </div>
    </div>
    
    <div class="features-section">
      <h2 class="section-title">Key Features</h2>
      <div class="key-features">
        <div class="key-feature">
          <div class="key-feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path>
              <path d="M12 6v6l4 2"></path>
            </svg>
          </div>
          <div class="key-feature-content">
            <h3>Real-time Analysis</h3>
            <p>Advanced audio analysis that detects beats, vocals, and instruments separately for precise visualization.</p>
          </div>
        </div>
        <div class="key-feature">
          <div class="key-feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 3v18"></path>
              <path d="M6 9l6-6 6 6"></path>
              <path d="M6 15l6 6 6-6"></path>
            </svg>
          </div>
          <div class="key-feature-content">
            <h3>Customizable</h3>
            <p>Fine-tune every aspect of your visualizations with advanced settings for colors, sensitivity, and effects.</p>
          </div>
        </div>
        <div class="key-feature">
          <div class="key-feature-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
            </svg>
          </div>
          <div class="key-feature-content">
            <h3>Mood Adaptive</h3>
            <p>Visualizations adapt to the mood and genre of your music, creating a unique experience for every track.</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="redirect-notice">
      <strong>Important:</strong> Make sure your Spotify Developer Dashboard has this <strong>exact</strong> redirect URI:
      <code>https://spotiplayer-tau.vercel.app/</code>
      <small>The trailing slash is important! It must match exactly.</small>
    </div>
  </div>

  <!-- Visualizer UI -->
  <div id="visualizer-ui" class="visualizer-ui">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-header">
        <div class="logo">
          <svg class="logo-icon" width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM16.5 16.5C16.23 16.5 15.96 16.38 15.75 16.17C14.72 15.14 13.23 14.5 11.5 14.5C9.77 14.5 8.28 15.14 7.25 16.17C7.04 16.38 6.77 16.5 6.5 16.5C5.95 16.5 5.5 16.05 5.5 15.5C5.5 15.23 5.62 14.96 5.83 14.75C7.14 13.44 9.07 12.5 11.5 12.5C13.93 12.5 15.86 13.44 17.17 14.75C17.38 14.96 17.5 15.23 17.5 15.5C17.5 16.05 17.05 16.5 16.5 16.5ZM17.5 12C16.67 12 16 11.33 16 10.5C16 9.67 16.67 9 17.5 9C18.33 9 19 9.67 19 10.5C19 11.33 18.33 12 17.5 12ZM5.5 12C4.67 12 4 11.33 4 10.5C4 9.67 4.67 9 5.5 9C6.33 9 7 9.67 7 10.5C7 11.33 6.33 12 5.5 12Z" fill="currentColor"/>
          </svg>
          <span class="logo-text">SpotiViz</span>
        </div>
        <button class="sidebar-toggle" id="sidebar-toggle">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      
      <div class="sidebar-content">
        <div class="sidebar-section">
          <h3 class="sidebar-title">Visualizations</h3>
          <div class="visualization-list">
            <button class="viz-option active" data-viz="spectrum">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="4" y="4" width="16" height="16" rx="2" stroke="currentColor" stroke-width="2"/>
                <rect x="7" y="14" width="2" height="4" fill="currentColor"/>
                <rect x="11" y="8" width="2" height="10" fill="currentColor"/>
                <rect x="15" y="10" width="2" height="8" fill="currentColor"/>
              </svg>
              <span>Spectrum</span>
            </button>
            <button class="viz-option" data-viz="orbital">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                <circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/>
                <circle cx="12" cy="12" r="1" fill="currentColor"/>
              </svg>
              <span>Orbital</span>
            </button>
            <button class="viz-option" data-viz="nebula">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 3a9 9 0 0 0-9 9 9 9 0 0 0 9 9 9 9 0 0 0 9-9 9 9 0 0 0-9-9z" stroke="currentColor" stroke-width="2"/>
                <path d="M8 12a4 4 0 0 1 8 0" stroke="currentColor" stroke-width="2"/>
                <circle cx="16" cy="9" r="1" fill="currentColor"/>
                <circle cx="8" cy="15" r="1" fill="currentColor"/>
                <circle cx="12" cy="12" r="1" fill="currentColor"/>
              </svg>
              <span>Nebula</span>
            </button>
            <button class="viz-option" data-viz="terrain">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M2 18h20M7 14l-3 4M12 12l-3 6M17 9l-4 9M22 6l-5 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
              <span>Terrain</span>
            </button>
          </div>
        </div>
        
        <div class="sidebar-section">
          <h3 class="sidebar-title">Settings</h3>
          <div class="settings-list">
            <div class="setting-item">
              <div class="setting-label">
                <span>Sensitivity</span>
                <span class="setting-value" id="sensitivity-value">50%</span>
              </div>
              <input type="range" min="0" max="100" value="50" class="slider" id="sensitivity-slider">
            </div>
            
            <div class="setting-item">
              <div class="setting-label">
                <span>Bass Boost</span>
                <span class="setting-value" id="bass-value">30%</span>
              </div>
              <input type="range" min="0" max="100" value="30" class="slider" id="bass-slider">
            </div>
            
            <div class="setting-item">
              <div class="setting-label">
                <span>Color Theme</span>
              </div>
              <div class="color-options">
                <button class="color-option active" data-theme="spotify" style="background: linear-gradient(45deg, #1DB954, #191414);"></button>
                <button class="color-option" data-theme="sunset" style="background: linear-gradient(45deg, #FF8C00, #FF2D00);"></button>
                <button class="color-option" data-theme="ocean" style="background: linear-gradient(45deg, #0072FF, #00C6FF);"></button>
                <button class="color-option" data-theme="purple" style="background: linear-gradient(45deg, #8E2DE2, #4A00E0);"></button>
              </div>
            </div>
            
            <div class="setting-item">
              <div class="setting-label">
                <span>Motion Speed</span>
                <span class="setting-value" id="speed-value">60%</span>
              </div>
              <input type="range" min="0" max="100" value="60" class="slider" id="speed-slider">
            </div>
          </div>
        </div>
        
        <div class="sidebar-section">
          <h3 class="sidebar-title">Advanced</h3>
          <div class="advanced-settings">
            <div class="setting-toggle">
              <span>High Quality Mode</span>
              <label class="switch">
                <input type="checkbox" id="quality-toggle">
                <span class="switch-slider"></span>
              </label>
            </div>
            
            <div class="setting-toggle">
              <span>Fullscreen Mode</span>
              <label class="switch">
                <input type="checkbox" id="fullscreen-toggle">
                <span class="switch-slider"></span>
              </label>
            </div>
            
            <div class="setting-toggle">
              <span>Show FPS</span>
              <label class="switch">
                <input type="checkbox" id="fps-toggle">
                <span class="switch-slider"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
      
      <div class="sidebar-footer">
        <div class="track-info-mini">
          <img id="album-art-mini" class="album-art-mini" src="" alt="Album Art">
          <div class="track-details-mini">
            <h4 id="track-name-mini">Not Playing</h4>
            <p id="artist-name-mini">Connect to Spotify</p>
          </div>
        </div>
        
        <button class="disconnect-button" id="disconnect-button">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span>Disconnect</span>
        </button>
      </div>
    </div>
    
    <!-- Main Visualizer Area -->
    <div class="visualizer-main">
      <!-- Track Info Overlay -->
      <div class="track-info-overlay">
        <div class="track-info-container">
          <img id="album-art" class="album-art-large" src="" alt="Album Art">
          <div class="track-details-large">
            <h2 id="track-name">Track Name</h2>
            <p id="artist-name">Artist Name</p>
            <div class="track-meta">
              <span id="album-name">Album Name</span>
              <span class="meta-separator">â€¢</span>
              <span id="release-year">2023</span>
            </div>
          </div>
        </div>
        
        <div class="audio-info">
          <div class="audio-feature">
            <span class="feature-label">BPM</span>
            <span class="feature-value" id="track-tempo">120</span>
          </div>
          <div class="audio-feature">
            <span class="feature-label">Key</span>
            <span class="feature-value" id="track-key">C Major</span>
          </div>
          <div class="audio-feature">
            <span class="feature-label">Energy</span>
            <div class="feature-bar-container">
              <div class="feature-bar" id="energy-bar" style="width: 75%"></div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Visualizer Controls -->
      <div class="visualizer-controls">
        <button class="control-button" id="settings-toggle">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        
        <div class="viz-mode-indicator">
          <span id="current-viz-mode">Spectrum</span>
        </div>
        
        <button class="control-button" id="fullscreen-button">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      
      <!-- FPS Counter -->
      <div class="fps-counter" id="fps-counter">60 FPS</div>
    </div>
  </div>
  
  <!-- Track change notification -->
  <div id="track-notification" class="track-notification">
    <div class="notification-content">
      <img id="notification-art" src="" alt="Album Art">
      <div class="notification-text">
        <p>Now Playing</p>
        <h4 id="notification-track">Track Name</h4>
        <p id="notification-artist">Artist Name</p>
      </div>
    </div>
  </div>

  <!-- Debug panel -->
  <div id="debug-panel">
    <h3>Debug Info</h3>
    <div id="debug-content"></div>
    <button onclick="document.getElementById('debug-panel').style.display='none'">Close</button>
  </div>

  <!-- Loading animation -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
  </div>

  <!-- Custom cursor (hidden on mobile) -->
  <div class="cursor" id="cursor"></div>
  <div class="cursor-dot" id="cursor-dot"></div>

  <!-- Scripts -->
  <script>
    // Spotify API credentials
    const clientId = 'd37b7146ee274b33bf6539611a0c307e';
    
    // IMPORTANT: This must match EXACTLY what's in the Spotify Developer Dashboard
    // Using hardcoded value to ensure it matches
    const redirectUri = 'https://spotiplayer-tau.vercel.app/';
    console.log('Using redirect URI:', redirectUri);
    
    // Spotify API endpoints
    const authEndpoint = 'https://accounts.spotify.com/authorize';
    const tokenEndpoint = 'https://accounts.spotify.com/api/token';
    const apiEndpoint = 'https://api.spotify.com/v1';
    
    // Required scopes for the app
    const scopes = [
      'user-read-currently-playing',
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-private',
      'user-read-email',
      'streaming'
    ];
    
    // DOM elements
    const spotifyLoginButton = document.getElementById('spotify-login');
    const loadingElement = document.getElementById('loading');
    const visualizerUI = document.getElementById('visualizer-ui');
    const sidebar = document.querySelector('.sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const settingsToggle = document.getElementById('settings-toggle');
    const fullscreenButton = document.getElementById('fullscreen-button');
    const disconnectButton = document.getElementById('disconnect-button');
    const albumArtElement = document.getElementById('album-art');
    const albumArtMiniElement = document.getElementById('album-art-mini');
    const trackNameElement = document.getElementById('track-name');
    const trackNameMiniElement = document.getElementById('track-name-mini');
    const artistNameElement = document.getElementById('artist-name');
    const artistNameMiniElement = document.getElementById('artist-name-mini');
    const albumNameElement = document.getElementById('album-name');
    const releaseYearElement = document.getElementById('release-year');
    const trackTempoElement = document.getElementById('track-tempo');
    const trackKeyElement = document.getElementById('track-key');
    const energyBarElement = document.getElementById('energy-bar');
    const currentVizModeElement = document.getElementById('current-viz-mode');
    const fpsCounterElement = document.getElementById('fps-counter');
    const canvas = document.getElementById('canvas');
    const cursor = document.getElementById('cursor');
    const cursorDot = document.getElementById('cursor-dot');
    const typingText = document.getElementById('typing-text');
    
    // Global variables
    let accessToken = null;
    let refreshToken = null;
    let player = null;
    let deviceId = null;
    let currentTrack = null;
    let isPlaying = false;
    let progressInterval = null;
    
    // Animation frame reference for cancellation
    window.animationFrame = null;
    
    // Playback check interval
    let playbackCheckInterval = null;
    
    // Beat tracking interval
    window.beatTrackingInterval = null;
    
    // Visualization settings
    let currentVisualizationMode = 'spectrum';
    let sensitivity = 50;
    let bassBoost = 30;
    let motionSpeed = 60;
    let colorTheme = 'spotify';
    let highQualityMode = false;
    let showFps = false;
    let isFullscreen = false;
    
    // Audio analysis data
    let audioFeatures = null;
    let audioAnalysis = null;
    
    // FPS tracking
    let fpsTime = 0;
    let frameCount = 0;
    let fps = 0;
    
    // Debug logging function
    function debugLog(message, data) {
      console.log(message, data);
      
      // Add to debug panel
      const debugContent = document.getElementById('debug-content');
      const timestamp = new Date().toLocaleTimeString();
      const messageHtml = `<div><strong>${timestamp}:</strong> ${message}</div>`;
      
      if (data) {
        const dataStr = typeof data === 'object' ? JSON.stringify(data) : data.toString();
        debugContent.innerHTML += `${messageHtml}<pre>${dataStr}</pre>`;
      } else {
        debugContent.innerHTML += messageHtml;
      }
      
      // Auto-scroll to bottom
      debugContent.scrollTop = debugContent.scrollHeight;
    }
    
    // Show debug panel with keyboard shortcut (Ctrl+D)
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.key === 'd') {
        e.preventDefault();
        const debugPanel = document.getElementById('debug-panel');
        debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
      }
    });
    
    // Show debug panel with button click
    document.getElementById('show-debug').addEventListener('click', function(e) {
      e.preventDefault();
      document.getElementById('debug-panel').style.display = 'block';
    });
    
    // Check if we're returning from Spotify auth
    window.onload = function() {
      // Initialize canvas
      initCanvas();
      
      // Initialize typing animation
      initTypingAnimation();
      
      // Initialize custom cursor
      initCustomCursor();
      
      // Set up settings UI elements
      setupSettingsUI();
      
      // Log environment info
      debugLog('App initialized', {
        url: window.location.href,
        redirectUri: redirectUri,
        clientId: clientId
      });
    }
    
    // Set up settings UI elements
    function setupSettingsUI() {
      // Set up settings sliders
      if (sensitivitySlider) {
        sensitivitySlider.addEventListener('input', () => {
          sensitivity = parseInt(sensitivitySlider.value);
          sensitivityValue.textContent = `${sensitivity}%`;
        });
      }
      
      if (bassSlider) {
        bassSlider.addEventListener('input', () => {
          bassBoost = parseInt(bassSlider.value);
          bassValue.textContent = `${bassBoost}%`;
        });
      }
      
      if (speedSlider) {
        speedSlider.addEventListener('input', () => {
          motionSpeed = parseInt(speedSlider.value);
          speedValue.textContent = `${motionSpeed}%`;
        });
      }
      
      // Set up quality toggle
      if (qualityToggle) {
        qualityToggle.addEventListener('change', () => {
          highQualityMode = qualityToggle.checked;
          updateVisualizationQuality();
        });
      }
      
      // Set up fullscreen toggle
      if (fullscreenToggle) {
        fullscreenToggle.addEventListener('change', () => {
          if (fullscreenToggle.checked) {
            enterFullscreen();
          } else {
            exitFullscreen();
          }
        });
      }
      
      // Set up FPS toggle
      if (fpsToggle) {
        fpsToggle.addEventListener('change', () => {
          showFps = fpsToggle.checked;
          fpsCounterElement.style.display = showFps ? 'block' : 'none';
        });
      }
      
      // Set up color theme options
      if (colorOptions) {
        colorOptions.forEach(option => {
          option.addEventListener('click', () => {
            // Remove active class from all options
            colorOptions.forEach(opt => opt.classList.remove('active'));
            
            // Add active class to clicked option
            option.classList.add('active');
            
            // Set color theme
            colorTheme = option.dataset.theme;
            updateColorTheme();
          });
        });
      }
      
      // Set up visualization mode buttons
      if (vizOptions) {
        vizOptions.forEach(option => {
          option.addEventListener('click', () => {
            // Remove active class from all options
            vizOptions.forEach(opt => opt.classList.remove('active'));
            
            // Add active class to clicked option
            option.classList.add('active');
            
            // Set current visualization mode
            currentVisualizationMode = option.dataset.viz;
            if (currentVizModeElement) {
              currentVizModeElement.textContent = option.querySelector('span').textContent;
            }
            
            // Update visualization
            updateVisualizationMode(currentVisualizationMode);
          });
        });
      }
      
      // We're using direct client-side auth only
      
      // Check for error parameter in query string (from client-side auth)
      const urlParams = new URLSearchParams(window.location.search);
      const error = urlParams.get('error');
      const errorDescription = urlParams.get('error_description');
      
      if (error) {
        debugLog('Authentication error', { error, errorDescription });
        loadingElement.style.display = 'none';
        
        // Show error in debug panel and make it visible
        document.getElementById('debug-panel').style.display = 'block';
        
        // Show alert with more helpful message
        if (error === 'invalid_client') {
          alert(`Authentication Error: Invalid client. This usually means the redirect URI doesn't match what's registered in your Spotify Developer Dashboard.\n\nMake sure you have registered this exact redirect URI: ${redirectUri}\n\nPress Ctrl+D to see debug info.`);
        } else {
          alert(`Authentication Error: ${error}\n${errorDescription}\n\nPress Ctrl+D to see debug info.`);
        }
        return;
      }
      
      const code = urlParams.get('code');
      
      if (code) {
        // Show loading animation
        loadingElement.style.display = 'flex';
        
        debugLog('Authorization code received', { code: code.substring(0, 10) + '...' });
        debugLog('Using redirect URI', { redirectUri });
        
        // Exchange code for access token
        exchangeCodeForToken(code);
      } else {
        debugLog('No authorization code found, checking for stored token');
        
        // Check if we have a stored token
        const storedToken = localStorage.getItem('spotify_access_token');
        const storedRefreshToken = localStorage.getItem('spotify_refresh_token');
        const tokenExpiry = localStorage.getItem('token_expiry');
        
        if (storedToken && tokenExpiry && new Date().getTime() < parseInt(tokenExpiry)) {
          debugLog('Valid stored token found');
          accessToken = storedToken;
          refreshToken = storedRefreshToken;
          initializePlayer();
        } else if (storedRefreshToken) {
          debugLog('Token expired, refreshing');
          refreshAccessToken(storedRefreshToken);
        } else {
          debugLog('No stored tokens found');
          // Show debug panel by default to help troubleshoot
          document.getElementById('debug-panel').style.display = 'block';
        }
      }
    };
    
    // Handle login button click
    spotifyLoginButton.addEventListener('click', function() {
      // Always use client-side flow for now
      const authUrl = `${authEndpoint}?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&scope=${encodeURIComponent(scopes.join(' '))}&response_type=code&show_dialog=true`;
      window.location.href = authUrl;
    });
    
    // Exchange authorization code for access token
    function exchangeCodeForToken(code) {
      console.log('Exchanging code for token...');
      
      // Create a temporary form to send the request
      const body = new URLSearchParams();
      body.append('grant_type', 'authorization_code');
      body.append('code', code);
      body.append('redirect_uri', redirectUri);
      body.append('client_id', clientId);
      body.append('client_secret', '73a3292d161147f898e7c4fb52fe3498');
      
      console.log('Using redirect URI for token exchange:', redirectUri);
      
      fetch(tokenEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: body
      })
      .then(response => {
        console.log('Token exchange response status:', response.status);
        
        // Clone the response so we can read it twice
        const responseClone = response.clone();
        
        // Read the response as text for debugging
        responseClone.text().then(text => {
          try {
            const errorData = JSON.parse(text);
            console.log('Response data:', errorData);
            
            if (errorData.error === 'invalid_client') {
              console.error('Invalid client error. This usually means the redirect URI does not match what is registered in Spotify Developer Dashboard.');
              console.error('Make sure you have registered the following redirect URI in your Spotify Developer Dashboard:');
              console.error(redirectUri);
              
              // Show a more helpful error message
              loadingElement.style.display = 'none';
              alert(`Authentication Error: Invalid client. Please make sure the following redirect URI is registered in your Spotify Developer Dashboard: ${redirectUri}`);
              return;
            }
          } catch (e) {
            // Not JSON or other error, continue with normal flow
          }
        });
        
        if (!response.ok) {
          throw new Error('HTTP status ' + response.status);
        }
        
        return response.json();
      })
      .then(data => {
        if (!data) return; // Skip if we already handled an error
        
        console.log('Token exchange successful!');
        accessToken = data.access_token;
        refreshToken = data.refresh_token;
        
        // Store tokens
        const expiryTime = new Date().getTime() + (data.expires_in * 1000);
        localStorage.setItem('spotify_access_token', accessToken);
        localStorage.setItem('spotify_refresh_token', refreshToken);
        localStorage.setItem('token_expiry', expiryTime.toString());
        
        // Remove code from URL without refreshing the page
        window.history.replaceState({}, document.title, '/');
        
        // Initialize player
        initializePlayer();
      })
      .catch(error => {
        console.error('Error exchanging code for token:', error);
        loadingElement.style.display = 'none';
        
        // Show a more detailed error message
        const errorMessage = 'Failed to authenticate with Spotify. ' +
          'Please make sure you have registered the correct redirect URI in your Spotify Developer Dashboard: ' +
          redirectUri;
        
        alert(errorMessage);
      });
    }
    
    // Refresh access token
    function refreshAccessToken(refreshToken) {
      loadingElement.style.display = 'flex';
      
      // Client-side refresh token flow
      const body = new URLSearchParams();
      body.append('grant_type', 'refresh_token');
      body.append('refresh_token', refreshToken);
      body.append('client_id', clientId);
      body.append('client_secret', '73a3292d161147f898e7c4fb52fe3498');
      
      fetch(tokenEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: body
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('HTTP status ' + response.status);
        }
        return response.json();
      })
      .then(data => {
        accessToken = data.access_token;
        
        // Store new access token
        const expiryTime = new Date().getTime() + (data.expires_in * 1000);
        localStorage.setItem('spotify_access_token', accessToken);
        localStorage.setItem('token_expiry', expiryTime.toString());
        
        // Initialize player
        initializePlayer();
      })
      .catch(error => {
        console.error('Error refreshing token:', error);
        loadingElement.style.display = 'none';
        localStorage.removeItem('spotify_access_token');
        localStorage.removeItem('spotify_refresh_token');
        localStorage.removeItem('token_expiry');
      });
    }
    
    // Initialize the player
    function initializePlayer() {
      // Load Spotify Web Playback SDK
      const script = document.createElement('script');
      script.src = 'https://sdk.scdn.co/spotify-player.js';
      script.async = true;
      document.body.appendChild(script);
      
      // Load saved visualization settings
      loadVisualizationSettings();
      
      // Initialize Spotify Web Playback SDK
      window.onSpotifyWebPlaybackSDKReady = () => {
        player = new Spotify.Player({
          name: 'SpotiVisualizer',
          getOAuthToken: cb => { cb(accessToken); },
          volume: 0.5
        });
        
        // Error handling
        player.addListener('initialization_error', ({ message }) => {
          console.error('Initialization error:', message);
          loadingElement.style.display = 'none';
        });
        
        player.addListener('authentication_error', ({ message }) => {
          console.error('Authentication error:', message);
          loadingElement.style.display = 'none';
          
          // Try to refresh the token
          if (refreshToken) {
            refreshAccessToken(refreshToken);
          }
        });
        
        player.addListener('account_error', ({ message }) => {
          console.error('Account error:', message);
          loadingElement.style.display = 'none';
          alert('Premium account required for playback. Please upgrade your Spotify account.');
        });
        
        player.addListener('playback_error', ({ message }) => {
          console.error('Playback error:', message);
        });
        
        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Ready with Device ID', device_id);
          deviceId = device_id;
          
          // Prepare for transition
          visualizerUI.style.display = 'block';
          visualizerUI.style.opacity = '0';
          
          // Hide loading
          loadingElement.style.display = 'none';
          
          // Fade out landing page
          const landingContainer = document.querySelector('.landing-container');
          const appHeader = document.querySelector('.app-header');
          
          landingContainer.style.transition = 'opacity 0.5s ease';
          appHeader.style.transition = 'opacity 0.5s ease';
          
          landingContainer.style.opacity = '0';
          appHeader.style.opacity = '0';
          
          // Initialize visualizer settings
          initializeVisualizerSettings();
          
          // After a short delay, complete the transition
          setTimeout(() => {
            // Hide landing page completely
            landingContainer.style.display = 'none';
            appHeader.style.display = 'none';
            
            // Fade in visualizer UI
            visualizerUI.style.transition = 'opacity 0.5s ease';
            visualizerUI.style.opacity = '1';
            
            // Update visualization to current mode
            updateVisualizationMode(currentVisualizationMode);
          }, 500);
          
          // Get current playback state
          getCurrentPlayback();
        });
        
        // Not Ready
        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
        });
        
        // State changes
        player.addListener('player_state_changed', state => {
          if (!state) return;
          
          currentTrack = state.track_window.current_track;
          isPlaying = !state.paused;
          
          // Update UI
          updatePlayerUI(state);
        });
        
        // Connect to the player
        player.connect();
      };
    }
    
    // Get current playback state
    function getCurrentPlayback() {
      fetch(`${apiEndpoint}/me/player`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      })
      .then(response => {
        if (response.status === 204) {
          // No active device
          transferPlayback();
          return null;
        }
        return response.json();
      })
      .then(data => {
        if (data) {
          currentTrack = data.item;
          isPlaying = data.is_playing;
          
          // Update UI
          updatePlayerUIFromAPI(data);
        }
      })
      .catch(error => {
        console.error('Error getting current playback:', error);
      });
    }
    
    // Transfer playback to this device
    function transferPlayback() {
      fetch(`${apiEndpoint}/me/player`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          device_ids: [deviceId],
          play: false
        })
      })
      .then(() => {
        // Start with a recommended track
        playRecommendedTrack();
      })
      .catch(error => {
        console.error('Error transferring playback:', error);
      });
    }
    
    // Play a recommended track
    function playRecommendedTrack() {
      // Get user's top tracks or featured playlists
      fetch(`${apiEndpoint}/browse/featured-playlists?limit=1`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.playlists && data.playlists.items.length > 0) {
          const playlistId = data.playlists.items[0].id;
          
          // Get tracks from the playlist
          return fetch(`${apiEndpoint}/playlists/${playlistId}/tracks?limit=10`, {
            headers: {
              'Authorization': `Bearer ${accessToken}`
            }
          });
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.items && data.items.length > 0) {
          // Play the first track
          const trackUri = data.items[0].track.uri;
          
          fetch(`${apiEndpoint}/me/player/play?device_id=${deviceId}`, {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              uris: [trackUri]
            })
          });
        }
      })
      .catch(error => {
        console.error('Error playing recommended track:', error);
      });
    }
    
    // Track change detection
    let previousTrackId = null;
    
    // Update player UI from Web Playback SDK state
    function updatePlayerUI(state) {
      if (!state || !state.track_window || !state.track_window.current_track) return;
      
      const track = state.track_window.current_track;
      
      // Check if track has changed
      if (previousTrackId !== track.id) {
        // Show track change notification
        showTrackNotification(track);
        previousTrackId = track.id;
        
        // Get audio features and analysis for the new track
        getAudioFeatures(track.id);
      }
      
      // Update track info
      updateTrackInfo(track);
      
      // Update visualization based on audio features
      updateVisualization(track);
    }
    
    // Update player UI from API response
    function updatePlayerUIFromAPI(data) {
      if (!data || !data.item) return;
      
      const track = data.item;
      
      // Check if track has changed
      if (previousTrackId !== track.id) {
        // Show track change notification
        showTrackNotification(track);
        previousTrackId = track.id;
        
        // Get audio features and analysis for the new track
        getAudioFeatures(track.id);
      }
      
      // Update track info
      updateTrackInfo(track);
      
      // Update visualization based on audio features
      updateVisualization(track);
    }
    
    // Update track info in UI
    function updateTrackInfo(track) {
      // Main track info
      trackNameElement.textContent = track.name;
      artistNameElement.textContent = track.artists.map(artist => artist.name).join(', ');
      albumArtElement.src = track.album.images[0].url;
      
      // Mini track info in sidebar
      trackNameMiniElement.textContent = track.name;
      artistNameMiniElement.textContent = track.artists.map(artist => artist.name).join(', ');
      albumArtMiniElement.src = track.album.images[0].url;
      
      // Album info
      albumNameElement.textContent = track.album.name;
      
      // Try to extract release year from album release date
      if (track.album.release_date) {
        const releaseYear = track.album.release_date.split('-')[0];
        releaseYearElement.textContent = releaseYear;
      }
      
      // Update document title
      const artistNames = track.artists.map(artist => artist.name).join(', ');
      document.title = `${track.name} - ${artistNames} | SpotiVisualizer`;
    }
    
    // Get audio features for a track
    function getAudioFeatures(trackId) {
      console.log('Getting audio features for track:', trackId);
      
      // Show loading indicator for audio features
      const loadingIndicator = document.createElement('div');
      loadingIndicator.id = 'audio-features-loading';
      loadingIndicator.innerHTML = '<div class="spinner"></div><div>Analyzing audio...</div>';
      loadingIndicator.style.position = 'absolute';
      loadingIndicator.style.top = '20px';
      loadingIndicator.style.right = '20px';
      loadingIndicator.style.background = 'rgba(0, 0, 0, 0.7)';
      loadingIndicator.style.color = 'white';
      loadingIndicator.style.padding = '10px 15px';
      loadingIndicator.style.borderRadius = '5px';
      loadingIndicator.style.display = 'flex';
      loadingIndicator.style.alignItems = 'center';
      loadingIndicator.style.gap = '10px';
      loadingIndicator.style.zIndex = '1000';
      loadingIndicator.style.fontSize = '14px';
      
      // Add spinner style
      const spinnerStyle = document.createElement('style');
      spinnerStyle.textContent = `
        #audio-features-loading .spinner {
          width: 20px;
          height: 20px;
          border: 2px solid rgba(255, 255, 255, 0.3);
          border-radius: 50%;
          border-top-color: white;
          animation: spin 1s ease-in-out infinite;
        }
      `;
      
      // Add to visualizer UI
      const existingIndicator = document.getElementById('audio-features-loading');
      if (!existingIndicator) {
        document.head.appendChild(spinnerStyle);
        document.querySelector('.visualizer-ui').appendChild(loadingIndicator);
      }
      
      // Fetch audio features
      fetch(`${apiEndpoint}/audio-features/${trackId}`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to fetch audio features');
        }
        return response.json();
      })
      .then(features => {
        console.log('Audio features received:', features);
        audioFeatures = features;
        
        // Update UI with audio features
        updateAudioFeaturesUI(features);
        
        // Get detailed audio analysis
        return fetch(`${apiEndpoint}/audio-analysis/${trackId}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to fetch audio analysis');
        }
        return response.json();
      })
      .then(analysis => {
        console.log('Audio analysis received');
        audioAnalysis = analysis;
        
        // Remove loading indicator
        const loadingIndicator = document.getElementById('audio-features-loading');
        if (loadingIndicator) {
          loadingIndicator.remove();
        }
        
        // Show success message
        const successIndicator = document.createElement('div');
        successIndicator.id = 'audio-features-success';
        successIndicator.innerHTML = '<i class="fas fa-check-circle"></i><div>Audio analysis complete</div>';
        successIndicator.style.position = 'absolute';
        successIndicator.style.top = '20px';
        successIndicator.style.right = '20px';
        successIndicator.style.background = 'rgba(29, 185, 84, 0.7)';
        successIndicator.style.color = 'white';
        successIndicator.style.padding = '10px 15px';
        successIndicator.style.borderRadius = '5px';
        successIndicator.style.display = 'flex';
        successIndicator.style.alignItems = 'center';
        successIndicator.style.gap = '10px';
        successIndicator.style.zIndex = '1000';
        successIndicator.style.fontSize = '14px';
        
        document.querySelector('.visualizer-ui').appendChild(successIndicator);
        
        // Remove success message after 3 seconds
        setTimeout(() => {
          const successIndicator = document.getElementById('audio-features-success');
          if (successIndicator) {
            successIndicator.style.opacity = '0';
            successIndicator.style.transition = 'opacity 0.5s ease';
            
            setTimeout(() => {
              if (successIndicator) {
                successIndicator.remove();
              }
            }, 500);
          }
        }, 3000);
        
        // Update visualization with detailed analysis
        updateVisualizationWithAnalysis();
        
        // Restart visualization to apply new audio features
        updateVisualizationMode(currentVisualizationMode);
      })
      .catch(error => {
        console.error('Error fetching audio data:', error);
        
        // Remove loading indicator
        const loadingIndicator = document.getElementById('audio-features-loading');
        if (loadingIndicator) {
          loadingIndicator.remove();
        }
        
        // Show error message
        const errorIndicator = document.createElement('div');
        errorIndicator.id = 'audio-features-error';
        errorIndicator.innerHTML = '<i class="fas fa-exclamation-circle"></i><div>Failed to analyze audio</div>';
        errorIndicator.style.position = 'absolute';
        errorIndicator.style.top = '20px';
        errorIndicator.style.right = '20px';
        errorIndicator.style.background = 'rgba(255, 0, 0, 0.7)';
        errorIndicator.style.color = 'white';
        errorIndicator.style.padding = '10px 15px';
        errorIndicator.style.borderRadius = '5px';
        errorIndicator.style.display = 'flex';
        errorIndicator.style.alignItems = 'center';
        errorIndicator.style.gap = '10px';
        errorIndicator.style.zIndex = '1000';
        errorIndicator.style.fontSize = '14px';
        
        document.querySelector('.visualizer-ui').appendChild(errorIndicator);
        
        // Remove error message after 5 seconds
        setTimeout(() => {
          const errorIndicator = document.getElementById('audio-features-error');
          if (errorIndicator) {
            errorIndicator.style.opacity = '0';
            errorIndicator.style.transition = 'opacity 0.5s ease';
            
            setTimeout(() => {
              if (errorIndicator) {
                errorIndicator.remove();
              }
            }, 500);
          }
        }, 5000);
      });
    }
    
    // Update UI with audio features
    function updateAudioFeaturesUI(features) {
      if (!features) return;
      
      // Update tempo (BPM)
      trackTempoElement.textContent = Math.round(features.tempo);
      
      // Update key
      const keys = ['C', 'Câ™¯/Dâ™­', 'D', 'Dâ™¯/Eâ™­', 'E', 'F', 'Fâ™¯/Gâ™­', 'G', 'Gâ™¯/Aâ™­', 'A', 'Aâ™¯/Bâ™­', 'B'];
      const modes = ['Minor', 'Major'];
      
      if (features.key >= 0 && features.mode >= 0) {
        trackKeyElement.textContent = `${keys[features.key]} ${modes[features.mode]}`;
      }
      
      // Update energy bar
      energyBarElement.style.width = `${features.energy * 100}%`;
    }
    
    // Update visualization with audio analysis
    function updateVisualizationWithAnalysis() {
      // This function will be called when we have detailed audio analysis
      console.log('Audio analysis updated');
      
      if (!audioAnalysis) return;
      
      // Extract useful information from audio analysis
      const { beats, bars, sections, segments, tatums } = audioAnalysis;
      
      console.log(`Track has ${beats.length} beats, ${bars.length} bars, ${sections.length} sections`);
      
      // Calculate average tempo and time signature
      const avgTempo = audioAnalysis.track.tempo;
      const timeSignature = audioAnalysis.track.time_signature;
      
      console.log(`Average tempo: ${avgTempo} BPM, Time signature: ${timeSignature}/4`);
      
      // Find loudest segments for bass drops
      const loudestSegments = [...segments]
        .sort((a, b) => b.loudness_max - a.loudness_max)
        .slice(0, 5);
      
      console.log('Loudest segments at:');
      loudestSegments.forEach(segment => {
        console.log(`${segment.start.toFixed(2)}s (loudness: ${segment.loudness_max.toFixed(2)} dB)`);
      });
      
      // Set up beat tracking for visualizations
      setupBeatTracking(beats, bars, sections);
    }
    
    // Set up beat tracking for visualizations
    function setupBeatTracking(beats, bars, sections) {
      // Clear any existing beat tracking
      if (window.beatTrackingInterval) {
        clearInterval(window.beatTrackingInterval);
      }
      
      // Current position in the track (in seconds)
      let currentPosition = 0;
      
      // Indices for tracking position in beats, bars, and sections
      let beatIndex = 0;
      let barIndex = 0;
      let sectionIndex = 0;
      
      // Get current playback state to sync
      fetch(`${apiEndpoint}/me/player`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      })
      .then(response => {
        if (response.status === 204) {
          return null;
        }
        return response.json();
      })
      .then(data => {
        if (data && data.progress_ms) {
          // Convert to seconds
          currentPosition = data.progress_ms / 1000;
          
          // Find current indices
          beatIndex = beats.findIndex(beat => beat.start > currentPosition);
          if (beatIndex === -1) beatIndex = 0;
          
          barIndex = bars.findIndex(bar => bar.start > currentPosition);
          if (barIndex === -1) barIndex = 0;
          
          sectionIndex = sections.findIndex(section => section.start > currentPosition);
          if (sectionIndex === -1) sectionIndex = 0;
          
          console.log(`Starting beat tracking at position ${currentPosition.toFixed(2)}s`);
          console.log(`Current beat: ${beatIndex}, bar: ${barIndex}, section: ${sectionIndex}`);
          
          // Start beat tracking
          startBeatTracking();
        }
      })
      .catch(error => {
        console.error('Error getting current playback position:', error);
        // Start beat tracking anyway
        startBeatTracking();
      });
      
      function startBeatTracking() {
        // Update position every 100ms
        window.beatTrackingInterval = setInterval(() => {
          // Only update if music is playing
          if (!isPlaying) return;
          
          // Increment position
          currentPosition += 0.1;
          
          // Check for beats
          while (beatIndex < beats.length && beats[beatIndex].start <= currentPosition) {
            // Beat detected
            triggerBeat(beats[beatIndex].confidence);
            beatIndex++;
          }
          
          // Check for bars
          while (barIndex < bars.length && bars[barIndex].start <= currentPosition) {
            // Bar detected
            triggerBar(bars[barIndex].confidence);
            barIndex++;
          }
          
          // Check for sections
          while (sectionIndex < sections.length && sections[sectionIndex].start <= currentPosition) {
            // Section change detected
            triggerSectionChange(sections[sectionIndex]);
            sectionIndex++;
          }
          
          // Reset if we've reached the end of the track
          if (beatIndex >= beats.length && barIndex >= bars.length && sectionIndex >= sections.length) {
            beatIndex = 0;
            barIndex = 0;
            sectionIndex = 0;
            currentPosition = 0;
          }
        }, 100);
      }
    }
    
    // Trigger visualization effects on beat
    function triggerBeat(confidence) {
      // Skip low-confidence beats
      if (confidence < 0.5) return;
      
      // Add beat indicator
      const beatIndicator = document.createElement('div');
      beatIndicator.className = 'beat-indicator';
      beatIndicator.style.position = 'absolute';
      beatIndicator.style.bottom = '20px';
      beatIndicator.style.left = '20px';
      beatIndicator.style.width = '10px';
      beatIndicator.style.height = '10px';
      beatIndicator.style.borderRadius = '50%';
      beatIndicator.style.backgroundColor = 'white';
      beatIndicator.style.opacity = '0.8';
      beatIndicator.style.transform = 'scale(1)';
      beatIndicator.style.transition = 'transform 0.1s ease-out, opacity 0.2s ease-out';
      
      document.querySelector('.visualizer-ui').appendChild(beatIndicator);
      
      // Animate and remove
      setTimeout(() => {
        beatIndicator.style.transform = 'scale(2)';
        beatIndicator.style.opacity = '0';
        
        setTimeout(() => {
          beatIndicator.remove();
        }, 200);
      }, 10);
      
      // Different effects based on visualization mode
      switch (currentVisualizationMode) {
        case 'fire':
          // Increase fire intensity temporarily
          if (audioFeatures) {
            audioFeatures.energy = Math.min(1, audioFeatures.energy * 1.5);
            setTimeout(() => {
              if (audioFeatures) {
                audioFeatures.energy = audioFeatures.energy / 1.5;
              }
            }, 200);
          }
          break;
          
        case 'liquid':
          // Add ripple effect
          // This is handled in the liquid visualization itself
          break;
          
        case 'starfield':
          // Increase warp effect temporarily
          if (audioFeatures) {
            const originalEnergy = audioFeatures.energy;
            audioFeatures.energy = Math.min(1, audioFeatures.energy * 1.5);
            setTimeout(() => {
              if (audioFeatures) {
                audioFeatures.energy = originalEnergy;
              }
            }, 200);
          }
          break;
      }
    }
    
    // Trigger visualization effects on bar
    function triggerBar(confidence) {
      // Skip low-confidence bars
      if (confidence < 0.5) return;
      
      // Add bar indicator
      const barIndicator = document.createElement('div');
      barIndicator.className = 'bar-indicator';
      barIndicator.style.position = 'absolute';
      barIndicator.style.bottom = '20px';
      barIndicator.style.left = '40px';
      barIndicator.style.width = '20px';
      barIndicator.style.height = '10px';
      barIndicator.style.borderRadius = '5px';
      barIndicator.style.backgroundColor = 'white';
      barIndicator.style.opacity = '0.8';
      barIndicator.style.transform = 'scaleX(1)';
      barIndicator.style.transition = 'transform 0.2s ease-out, opacity 0.3s ease-out';
      
      document.querySelector('.visualizer-ui').appendChild(barIndicator);
      
      // Animate and remove
      setTimeout(() => {
        barIndicator.style.transform = 'scaleX(2)';
        barIndicator.style.opacity = '0';
        
        setTimeout(() => {
          barIndicator.remove();
        }, 300);
      }, 10);
    }
    
    // Trigger visualization effects on section change
    function triggerSectionChange(section) {
      console.log('Section change:', section);
      
      // Add section indicator
      const sectionIndicator = document.createElement('div');
      sectionIndicator.className = 'section-indicator';
      sectionIndicator.textContent = `${section.confidence > 0.7 ? 'ðŸ”¥' : 'ðŸŽµ'} New section`;
      sectionIndicator.style.position = 'absolute';
      sectionIndicator.style.top = '60px';
      sectionIndicator.style.right = '20px';
      sectionIndicator.style.padding = '8px 15px';
      sectionIndicator.style.borderRadius = '5px';
      sectionIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      sectionIndicator.style.color = 'white';
      sectionIndicator.style.fontSize = '14px';
      sectionIndicator.style.opacity = '0';
      sectionIndicator.style.transform = 'translateX(20px)';
      sectionIndicator.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
      
      document.querySelector('.visualizer-ui').appendChild(sectionIndicator);
      
      // Animate in
      setTimeout(() => {
        sectionIndicator.style.opacity = '1';
        sectionIndicator.style.transform = 'translateX(0)';
        
        // Animate out and remove
        setTimeout(() => {
          sectionIndicator.style.opacity = '0';
          sectionIndicator.style.transform = 'translateX(20px)';
          
          setTimeout(() => {
            sectionIndicator.remove();
          }, 300);
        }, 3000);
      }, 10);
      
      // Adjust visualization based on section characteristics
      if (section.loudness > -10) {
        // Loud section - increase intensity
        if (audioFeatures) {
          const originalEnergy = audioFeatures.energy;
          audioFeatures.energy = Math.min(1, audioFeatures.energy * 1.3);
          
          setTimeout(() => {
            if (audioFeatures) {
              audioFeatures.energy = originalEnergy;
            }
          }, 5000);
        }
      }
    }
    
    // Show track change notification
    function showTrackNotification(track) {
      const notification = document.getElementById('track-notification');
      const notificationArt = document.getElementById('notification-art');
      const notificationTrack = document.getElementById('notification-track');
      const notificationArtist = document.getElementById('notification-artist');
      
      // Update notification content
      notificationArt.src = track.album?.images[0]?.url || '';
      notificationTrack.textContent = track.name;
      notificationArtist.textContent = track.artists?.map(artist => artist.name).join(', ') || '';
      
      // Show notification
      notification.classList.add('show');
      
      // Hide notification after 5 seconds
      setTimeout(() => {
        notification.classList.remove('show');
      }, 5000);
    }
    
    // Update play/pause button
    function updatePlayPauseButton(paused) {
      const playIcon = document.getElementById('play-icon');
      const pauseIcon = document.getElementById('pause-icon');
      
      if (paused) {
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
      } else {
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
      }
    }
    
    // Update visualization based on track
    function updateVisualization(track) {
      // This function will be called when the track changes
      console.log('Updating visualization for track:', track.name);
      
      // Reset any existing animation
      if (window.animationFrame) {
        cancelAnimationFrame(window.animationFrame);
        window.animationFrame = null;
      }
      
      // Get audio features and analysis for the track
      getAudioFeatures(track.id);
      
      // Update visualization mode based on current settings
      updateVisualizationMode(currentVisualizationMode);
      
      // Set up polling to check if music is actually playing
      if (playbackCheckInterval) {
        clearInterval(playbackCheckInterval);
      }
      
      playbackCheckInterval = setInterval(() => {
        // Check if music is still playing
        fetch(`${apiEndpoint}/me/player`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        })
        .then(response => {
          if (response.status === 204) {
            return null;
          }
          return response.json();
        })
        .then(data => {
          if (data) {
            // Update isPlaying state
            const wasPlaying = isPlaying;
            isPlaying = data.is_playing;
            
            // If playback state changed, update visualization
            if (wasPlaying !== isPlaying) {
              if (!isPlaying) {
                // Pause visualization
                pauseVisualization();
              } else {
                // Resume visualization
                resumeVisualization();
              }
            }
            
            // Check if track changed
            if (data.item && data.item.id !== track.id) {
              // Track changed, update UI and visualization
              currentTrack = data.item;
              updateTrackInfo(data.item);
              getAudioFeatures(data.item.id);
            }
          }
        })
        .catch(error => {
          console.error('Error checking playback state:', error);
        });
      }, 3000); // Check every 3 seconds
    }
    
    // Pause visualization when music is paused
    function pauseVisualization() {
      console.log('Pausing visualization');
      
      // Stop animation
      if (window.animationFrame) {
        cancelAnimationFrame(window.animationFrame);
        window.animationFrame = null;
      }
      
      // Show paused indicator
      const pausedIndicator = document.createElement('div');
      pausedIndicator.id = 'paused-indicator';
      pausedIndicator.innerHTML = '<i class="fas fa-pause"></i>';
      pausedIndicator.style.position = 'absolute';
      pausedIndicator.style.top = '50%';
      pausedIndicator.style.left = '50%';
      pausedIndicator.style.transform = 'translate(-50%, -50%)';
      pausedIndicator.style.fontSize = '5rem';
      pausedIndicator.style.color = 'rgba(255, 255, 255, 0.5)';
      pausedIndicator.style.zIndex = '1000';
      
      // Add to visualizer UI
      const existingIndicator = document.getElementById('paused-indicator');
      if (!existingIndicator) {
        document.querySelector('.visualizer-ui').appendChild(pausedIndicator);
      }
    }
    
    // Resume visualization when music plays
    function resumeVisualization() {
      console.log('Resuming visualization');
      
      // Remove paused indicator
      const pausedIndicator = document.getElementById('paused-indicator');
      if (pausedIndicator) {
        pausedIndicator.remove();
      }
      
      // Restart visualization
      updateVisualizationMode(currentVisualizationMode);
    }
    
    // Update visualization mode
    function updateVisualizationMode(mode) {
      // If music is not playing, don't start visualization
      if (!isPlaying) {
        pauseVisualization();
        return;
      }
      
      // Clear any existing animation
      if (window.animationFrame) {
        cancelAnimationFrame(window.animationFrame);
        window.animationFrame = null;
      }
      
      // Reset canvas
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update current visualization mode display
      if (currentVizModeElement) {
        const modeNames = {
          'spectrum': 'Spectrum',
          'orbital': 'Orbital',
          'nebula': 'Nebula',
          'terrain': 'Terrain',
          'fire': 'Fire',
          'liquid': 'Liquid',
          'starfield': 'Starfield'
        };
        currentVizModeElement.textContent = modeNames[mode] || 'Unknown';
      }
      
      // Start the appropriate visualization
      switch (mode) {
        case 'spectrum':
          startSpectrumVisualization();
          break;
        case 'orbital':
          startOrbitalVisualization();
          break;
        case 'nebula':
          startNebulaVisualization();
          break;
        case 'terrain':
          startTerrainVisualization();
          break;
        case 'fire':
          startFireVisualization();
          break;
        case 'liquid':
          startLiquidVisualization();
          break;
        case 'starfield':
          startStarfieldVisualization();
          break;
        default:
          startSpectrumVisualization();
      }
    }
    
    // Spectrum visualization
    function startSpectrumVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Number of bars
      const barCount = highQualityMode ? 128 : 64;
      
      // Bar properties
      const barWidth = width / barCount;
      const barSpacing = 2;
      const maxBarHeight = height * 0.6;
      
      // Generate random data for demo
      let audioData = new Array(barCount).fill(0);
      let targetData = new Array(barCount).fill(0);
      
      // Animation function
      function animate() {
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Get primary and secondary colors based on theme
        let primaryColor, secondaryColor;
        switch (colorTheme) {
          case 'spotify':
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
            break;
          case 'sunset':
            primaryColor = '#FF8C00';
            secondaryColor = '#FF2D00';
            break;
          case 'ocean':
            primaryColor = '#0072FF';
            secondaryColor = '#00C6FF';
            break;
          case 'purple':
            primaryColor = '#8E2DE2';
            secondaryColor = '#4A00E0';
            break;
          default:
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
        }
        
        // Create gradient
        const gradient = ctx.createLinearGradient(0, height, 0, 0);
        gradient.addColorStop(0, primaryColor);
        gradient.addColorStop(1, secondaryColor);
        
        // Update target data (simulating audio analysis)
        // In a real implementation, this would come from the Web Audio API
        for (let i = 0; i < barCount; i++) {
          // Apply bass boost to lower frequencies
          const bassBoostFactor = i < barCount / 3 ? (bassBoost / 100) * 2 + 1 : 1;
          
          // Generate random target based on frequency (lower frequencies tend to have more energy)
          const frequencyFactor = 1 - (i / barCount) * 0.8;
          targetData[i] = Math.random() * maxBarHeight * frequencyFactor * bassBoostFactor;
          
          // Apply sensitivity
          targetData[i] *= sensitivity / 50;
        }
        
        // Smooth transition to target data
        for (let i = 0; i < barCount; i++) {
          // Adjust speed based on motionSpeed setting
          const speedFactor = motionSpeed / 50;
          audioData[i] += (targetData[i] - audioData[i]) * 0.2 * speedFactor;
        }
        
        // Draw bars
        for (let i = 0; i < barCount; i++) {
          const x = i * (barWidth + barSpacing);
          const barHeight = audioData[i];
          
          // Draw bar with gradient
          ctx.fillStyle = gradient;
          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          
          // Add glow effect
          ctx.shadowBlur = 15;
          ctx.shadowColor = primaryColor;
          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          ctx.shadowBlur = 0;
        }
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    }
    
    // Orbital visualization
    function startOrbitalVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Center of the canvas
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Orbital properties
      const maxRadius = Math.min(width, height) * 0.4;
      const particleCount = highQualityMode ? 200 : 100;
      const particles = [];
      
      // Create particles
      for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * maxRadius;
        const size = Math.random() * 4 + 1;
        const speed = (Math.random() * 0.02 + 0.01) * (motionSpeed / 50);
        
        particles.push({
          angle,
          radius,
          size,
          speed,
          amplitude: Math.random() * 20 + 10,
          phase: Math.random() * Math.PI * 2
        });
      }
      
      // Animation function
      function animate() {
        // Clear canvas with slight fade effect for trails
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, width, height);
        
        // Get primary color based on theme
        let primaryColor;
        switch (colorTheme) {
          case 'spotify':
            primaryColor = '#1DB954';
            break;
          case 'sunset':
            primaryColor = '#FF8C00';
            break;
          case 'ocean':
            primaryColor = '#0072FF';
            break;
          case 'purple':
            primaryColor = '#8E2DE2';
            break;
          default:
            primaryColor = '#1DB954';
        }
        
        // Draw center circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
        ctx.fillStyle = primaryColor;
        ctx.fill();
        
        // Add glow to center
        ctx.shadowBlur = 20;
        ctx.shadowColor = primaryColor;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Update and draw particles
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          
          // Update angle
          p.angle += p.speed;
          
          // Calculate position with oscillation
          const oscillation = Math.sin(p.phase + Date.now() * 0.001) * p.amplitude;
          const currentRadius = p.radius + oscillation;
          
          const x = centerX + Math.cos(p.angle) * currentRadius;
          const y = centerY + Math.sin(p.angle) * currentRadius;
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(x, y, p.size, 0, Math.PI * 2);
          
          // Color based on distance from center
          const distanceRatio = currentRadius / maxRadius;
          const alpha = 1 - distanceRatio * 0.5;
          
          ctx.fillStyle = `rgba(${parseInt(primaryColor.slice(1, 3), 16)}, ${parseInt(primaryColor.slice(3, 5), 16)}, ${parseInt(primaryColor.slice(5, 7), 16)}, ${alpha})`;
          ctx.fill();
        }
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    }
    
    // Nebula visualization
    function startNebulaVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Particle properties
      const particleCount = highQualityMode ? 300 : 150;
      const particles = [];
      
      // Create particles
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 3 + 1,
          speedX: (Math.random() - 0.5) * 2 * (motionSpeed / 50),
          speedY: (Math.random() - 0.5) * 2 * (motionSpeed / 50),
          opacity: Math.random() * 0.5 + 0.2
        });
      }
      
      // Animation function
      function animate() {
        // Clear canvas with fade effect
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, width, height);
        
        // Get colors based on theme
        let primaryColor, secondaryColor;
        switch (colorTheme) {
          case 'spotify':
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
            break;
          case 'sunset':
            primaryColor = '#FF8C00';
            secondaryColor = '#FF2D00';
            break;
          case 'ocean':
            primaryColor = '#0072FF';
            secondaryColor = '#00C6FF';
            break;
          case 'purple':
            primaryColor = '#8E2DE2';
            secondaryColor = '#4A00E0';
            break;
          default:
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
        }
        
        // Convert hex to rgb
        const primaryRGB = {
          r: parseInt(primaryColor.slice(1, 3), 16),
          g: parseInt(primaryColor.slice(3, 5), 16),
          b: parseInt(primaryColor.slice(5, 7), 16)
        };
        
        const secondaryRGB = {
          r: parseInt(secondaryColor.slice(1, 3), 16),
          g: parseInt(secondaryColor.slice(3, 5), 16),
          b: parseInt(secondaryColor.slice(5, 7), 16)
        };
        
        // Update and draw particles
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          
          // Update position
          p.x += p.speedX;
          p.y += p.speedY;
          
          // Wrap around edges
          if (p.x < 0) p.x = width;
          if (p.x > width) p.x = 0;
          if (p.y < 0) p.y = height;
          if (p.y > height) p.y = 0;
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          
          // Mix colors based on position
          const mixRatio = p.y / height;
          const r = Math.floor(primaryRGB.r * (1 - mixRatio) + secondaryRGB.r * mixRatio);
          const g = Math.floor(primaryRGB.g * (1 - mixRatio) + secondaryRGB.g * mixRatio);
          const b = Math.floor(primaryRGB.b * (1 - mixRatio) + secondaryRGB.b * mixRatio);
          
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.opacity})`;
          ctx.fill();
        }
        
        // Draw connections between nearby particles
        ctx.strokeStyle = `rgba(${primaryRGB.r}, ${primaryRGB.g}, ${primaryRGB.b}, 0.1)`;
        ctx.lineWidth = 0.5;
        
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const p1 = particles[i];
            const p2 = particles[j];
            
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          }
        }
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    }
    
    // Terrain visualization
    function startTerrainVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Terrain properties
      const resolution = highQualityMode ? 2 : 4;
      const columns = width / resolution;
      const rows = 5;
      const terrain = [];
      
      // Initialize terrain
      for (let i = 0; i < columns; i++) {
        terrain[i] = [];
        for (let j = 0; j < rows; j++) {
          terrain[i][j] = 0;
        }
      }
      
      // Animation function
      function animate() {
        // Clear canvas
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);
        
        // Get colors based on theme
        let primaryColor, secondaryColor;
        switch (colorTheme) {
          case 'spotify':
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
            break;
          case 'sunset':
            primaryColor = '#FF8C00';
            secondaryColor = '#FF2D00';
            break;
          case 'ocean':
            primaryColor = '#0072FF';
            secondaryColor = '#00C6FF';
            break;
          case 'purple':
            primaryColor = '#8E2DE2';
            secondaryColor = '#4A00E0';
            break;
          default:
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
        }
        
        // Create gradient
        const gradient = ctx.createLinearGradient(0, height, 0, 0);
        gradient.addColorStop(0, primaryColor);
        gradient.addColorStop(1, secondaryColor);
        
        // Shift terrain down
        for (let i = 0; i < columns; i++) {
          for (let j = rows - 1; j > 0; j--) {
            terrain[i][j] = terrain[i][j - 1];
          }
        }
        
        // Generate new terrain at the top
        for (let i = 0; i < columns; i++) {
          // Apply bass boost to lower frequencies
          const bassBoostFactor = i < columns / 3 ? (bassBoost / 100) * 2 + 1 : 1;
          
          // Generate random height with frequency-dependent amplitude
          const frequencyFactor = 1 - (i / columns) * 0.8;
          terrain[i][0] = Math.random() * height * 0.3 * frequencyFactor * bassBoostFactor;
          
          // Apply sensitivity
          terrain[i][0] *= sensitivity / 50;
        }
        
        // Smooth terrain
        const smoothedTerrain = [];
        for (let i = 0; i < columns; i++) {
          smoothedTerrain[i] = [];
          for (let j = 0; j < rows; j++) {
            // Average with neighbors
            let sum = 0;
            let count = 0;
            
            for (let k = -2; k <= 2; k++) {
              const index = i + k;
              if (index >= 0 && index < columns) {
                sum += terrain[index][j];
                count++;
              }
            }
            
            smoothedTerrain[i][j] = sum / count;
          }
        }
        
        // Draw terrain
        for (let j = 0; j < rows; j++) {
          const rowHeight = height / rows;
          const y = j * rowHeight + rowHeight / 2;
          
          ctx.beginPath();
          ctx.moveTo(0, y);
          
          for (let i = 0; i < columns; i++) {
            const x = i * resolution;
            const terrainHeight = smoothedTerrain[i][j];
            ctx.lineTo(x, y - terrainHeight);
          }
          
          ctx.lineTo(width, y);
          ctx.lineTo(width, height);
          ctx.lineTo(0, height);
          ctx.closePath();
          
          // Fill with gradient and adjust opacity based on row
          const alpha = 1 - j * 0.15;
          ctx.fillStyle = `rgba(${parseInt(primaryColor.slice(1, 3), 16)}, ${parseInt(primaryColor.slice(3, 5), 16)}, ${parseInt(primaryColor.slice(5, 7), 16)}, ${alpha})`;
          ctx.fill();
          
          // Draw line on top
          ctx.beginPath();
          ctx.moveTo(0, y);
          
          for (let i = 0; i < columns; i++) {
            const x = i * resolution;
            const terrainHeight = smoothedTerrain[i][j];
            ctx.lineTo(x, y - terrainHeight);
          }
          
          ctx.lineTo(width, y);
          ctx.strokeStyle = primaryColor;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    }
    
    // Fire visualization
    function startFireVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Fire properties
      const fireWidth = Math.ceil(width / 4);
      const fireHeight = Math.ceil(height / 4);
      const firePixels = new Array(fireWidth * fireHeight).fill(0);
      const fireColorsPalette = [];
      
      // Generate fire color palette based on theme
      function generateFirePalette() {
        let primaryColor, secondaryColor;
        switch (colorTheme) {
          case 'spotify':
            primaryColor = [29, 185, 84]; // #1DB954
            secondaryColor = [255, 255, 0]; // Yellow
            break;
          case 'sunset':
            primaryColor = [255, 140, 0]; // #FF8C00
            secondaryColor = [255, 45, 0]; // #FF2D00
            break;
          case 'ocean':
            primaryColor = [0, 114, 255]; // #0072FF
            secondaryColor = [0, 198, 255]; // #00C6FF
            break;
          case 'purple':
            primaryColor = [142, 45, 226]; // #8E2DE2
            secondaryColor = [74, 0, 224]; // #4A00E0
            break;
          default:
            primaryColor = [255, 140, 0]; // #FF8C00
            secondaryColor = [255, 0, 0]; // Red
        }
        
        // Create 256 color palette for fire effect
        for (let i = 0; i < 256; i++) {
          // Black for the first few indices
          if (i < 20) {
            fireColorsPalette[i] = [0, 0, 0, 0]; // Transparent black
          } 
          // Gradient from black to primary color
          else if (i < 100) {
            const ratio = (i - 20) / 80;
            fireColorsPalette[i] = [
              Math.floor(primaryColor[0] * ratio),
              Math.floor(primaryColor[1] * ratio),
              Math.floor(primaryColor[2] * ratio),
              ratio
            ];
          } 
          // Gradient from primary to secondary color
          else if (i < 200) {
            const ratio = (i - 100) / 100;
            fireColorsPalette[i] = [
              Math.floor(primaryColor[0] * (1 - ratio) + secondaryColor[0] * ratio),
              Math.floor(primaryColor[1] * (1 - ratio) + secondaryColor[1] * ratio),
              Math.floor(primaryColor[2] * (1 - ratio) + secondaryColor[2] * ratio),
              1
            ];
          } 
          // Gradient to white for the hottest parts
          else {
            const ratio = (i - 200) / 55;
            fireColorsPalette[i] = [
              Math.floor(secondaryColor[0] * (1 - ratio) + 255 * ratio),
              Math.floor(secondaryColor[1] * (1 - ratio) + 255 * ratio),
              Math.floor(secondaryColor[2] * (1 - ratio) + 255 * ratio),
              1
            ];
          }
        }
      }
      
      // Initialize fire palette
      generateFirePalette();
      
      // Create fire source at bottom
      function createFireSource() {
        // The bottom row of the fire is the source
        for (let column = 0; column < fireWidth; column++) {
          const pixelIndex = (fireHeight - 1) * fireWidth + column;
          firePixels[pixelIndex] = 255; // Maximum heat
        }
      }
      
      // Spread fire upwards
      function spreadFire(srcIndex) {
        const pixel = firePixels[srcIndex];
        
        // If no fire, nothing to spread
        if (pixel === 0) {
          firePixels[srcIndex - fireWidth] = 0;
          return;
        }
        
        // Random decay based on sensitivity
        const decay = Math.floor(Math.random() * 3) * (100 - sensitivity) / 100;
        const newPixelValue = pixel - decay;
        const dstIndex = srcIndex - fireWidth;
        
        // Apply wind effect based on audio features
        let windOffset = 0;
        if (audioFeatures) {
          // Use energy to create wind effect
          const energy = audioFeatures.energy || 0.5;
          windOffset = Math.floor((Math.random() * 3 - 1) * energy * 2);
        }
        
        // Ensure we don't go out of bounds
        if (dstIndex + windOffset >= 0 && dstIndex + windOffset < firePixels.length) {
          firePixels[dstIndex + windOffset] = Math.max(0, newPixelValue);
        }
      }
      
      // Create fire effect
      function calculateFire() {
        // Process every pixel except the bottom row (source)
        for (let column = 0; column < fireWidth; column++) {
          for (let row = 0; row < fireHeight - 1; row++) {
            const pixelIndex = row * fireWidth + column;
            spreadFire(pixelIndex + fireWidth);
          }
        }
      }
      
      // Add bass pulse effect
      function addBassPulse() {
        if (!audioFeatures) return;
        
        // Use audio features to create bass pulses
        const energy = audioFeatures.energy || 0.5;
        const danceability = audioFeatures.danceability || 0.5;
        
        // Calculate pulse intensity based on bass boost and sensitivity
        const pulseIntensity = Math.floor(255 * energy * danceability * (bassBoost / 100) * (sensitivity / 100));
        
        // Apply pulse to bottom rows
        const pulseRows = Math.floor(fireHeight * 0.2); // Bottom 20%
        for (let row = fireHeight - pulseRows; row < fireHeight; row++) {
          for (let column = 0; column < fireWidth; column++) {
            const pixelIndex = row * fireWidth + column;
            // Add pulse intensity to existing fire
            firePixels[pixelIndex] = Math.min(255, firePixels[pixelIndex] + pulseIntensity);
          }
        }
      }
      
      // Render fire to canvas
      function renderFire() {
        // Create image data for efficient rendering
        const imageData = ctx.createImageData(fireWidth, fireHeight);
        const data = imageData.data;
        
        // Fill image data with fire colors
        for (let row = 0; row < fireHeight; row++) {
          for (let column = 0; column < fireWidth; column++) {
            const pixelIndex = row * fireWidth + column;
            const fireIntensity = firePixels[pixelIndex];
            const color = fireColorsPalette[fireIntensity];
            
            const dataIndex = (pixelIndex * 4);
            data[dataIndex] = color[0];     // R
            data[dataIndex + 1] = color[1]; // G
            data[dataIndex + 2] = color[2]; // B
            data[dataIndex + 3] = color[3] * 255; // A
          }
        }
        
        // Create temporary canvas for scaling
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = fireWidth;
        tempCanvas.height = fireHeight;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Put image data on temporary canvas
        tempCtx.putImageData(imageData, 0, 0);
        
        // Clear main canvas
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);
        
        // Draw scaled fire to main canvas with smoothing
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(tempCanvas, 0, 0, fireWidth, fireHeight, 0, 0, width, height);
        
        // Add glow effect
        ctx.globalCompositeOperation = 'lighter';
        ctx.filter = 'blur(10px)';
        ctx.globalAlpha = 0.3;
        ctx.drawImage(tempCanvas, 0, 0, fireWidth, fireHeight, 0, 0, width, height);
        
        // Reset composite operation and filter
        ctx.globalCompositeOperation = 'source-over';
        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
      }
      
      // Animation function
      function animate() {
        // Create fire source at bottom
        createFireSource();
        
        // Add bass pulse effect
        addBassPulse();
        
        // Calculate fire spread
        calculateFire();
        
        // Render fire to canvas
        renderFire();
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      createFireSource();
      animate();
    }
    
    // Liquid visualization
    function startLiquidVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Liquid properties
      const resolution = highQualityMode ? 2 : 4;
      const cols = Math.floor(width / resolution);
      const rows = Math.floor(height / resolution);
      
      // Wave properties
      const waves = [];
      const waveCount = 5;
      
      // Create initial waves
      for (let i = 0; i < waveCount; i++) {
        waves.push({
          amplitude: Math.random() * 50 + 20,
          wavelength: Math.random() * 100 + 100,
          speed: (Math.random() * 0.05 + 0.02) * (motionSpeed / 50),
          phase: Math.random() * Math.PI * 2
        });
      }
      
      // Animation function
      function animate() {
        // Clear canvas
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);
        
        // Get colors based on theme
        let primaryColor, secondaryColor;
        switch (colorTheme) {
          case 'spotify':
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
            break;
          case 'sunset':
            primaryColor = '#FF8C00';
            secondaryColor = '#FF2D00';
            break;
          case 'ocean':
            primaryColor = '#0072FF';
            secondaryColor = '#00C6FF';
            break;
          case 'purple':
            primaryColor = '#8E2DE2';
            secondaryColor = '#4A00E0';
            break;
          default:
            primaryColor = '#1DB954';
            secondaryColor = '#191414';
        }
        
        // Convert hex to rgb
        const primaryRGB = {
          r: parseInt(primaryColor.slice(1, 3), 16),
          g: parseInt(primaryColor.slice(3, 5), 16),
          b: parseInt(primaryColor.slice(5, 7), 16)
        };
        
        const secondaryRGB = {
          r: parseInt(secondaryColor.slice(1, 3), 16),
          g: parseInt(secondaryColor.slice(3, 5), 16),
          b: parseInt(secondaryColor.slice(5, 7), 16)
        };
        
        // Update wave phases
        for (let i = 0; i < waves.length; i++) {
          waves[i].phase += waves[i].speed;
          
          // Adjust amplitude based on audio features
          if (audioFeatures) {
            const energy = audioFeatures.energy || 0.5;
            const danceability = audioFeatures.danceability || 0.5;
            
            // Scale amplitude based on energy and bass boost
            const amplitudeScale = 1 + (energy * danceability * (bassBoost / 50));
            waves[i].amplitude = (Math.random() * 50 + 20) * amplitudeScale * (sensitivity / 50);
          }
        }
        
        // Draw liquid
        for (let y = 0; y < rows; y++) {
          // Create gradient for each row
          const gradient = ctx.createLinearGradient(0, y * resolution, width, y * resolution);
          
          // Mix colors based on position
          const mixRatio = y / rows;
          const r = Math.floor(primaryRGB.r * (1 - mixRatio) + secondaryRGB.r * mixRatio);
          const g = Math.floor(primaryRGB.g * (1 - mixRatio) + secondaryRGB.g * mixRatio);
          const b = Math.floor(primaryRGB.b * (1 - mixRatio) + secondaryRGB.b * mixRatio);
          
          gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
          gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.4)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          
          // Start at left edge
          ctx.moveTo(0, height);
          
          // Draw wave path
          for (let x = 0; x < cols; x++) {
            let waveHeight = 0;
            
            // Combine multiple waves
            for (let i = 0; i < waves.length; i++) {
              const wave = waves[i];
              const frequency = Math.PI * 2 / wave.wavelength;
              
              // Calculate wave height at this point
              waveHeight += Math.sin(x * frequency + wave.phase) * wave.amplitude;
            }
            
            // Apply row-based scaling (waves get smaller at the top)
            const rowFactor = 1 - (y / rows) * 0.8;
            waveHeight *= rowFactor;
            
            // Draw to this point
            ctx.lineTo(x * resolution, y * resolution + waveHeight);
          }
          
          // Complete the path
          ctx.lineTo(width, height);
          ctx.lineTo(0, height);
          ctx.closePath();
          ctx.fill();
          
          // Add highlights
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * (1 - y / rows)})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          
          for (let x = 0; x < cols; x++) {
            let waveHeight = 0;
            
            // Combine multiple waves
            for (let i = 0; i < waves.length; i++) {
              const wave = waves[i];
              const frequency = Math.PI * 2 / wave.wavelength;
              
              // Calculate wave height at this point
              waveHeight += Math.sin(x * frequency + wave.phase) * wave.amplitude;
            }
            
            // Apply row-based scaling
            const rowFactor = 1 - (y / rows) * 0.8;
            waveHeight *= rowFactor;
            
            // Draw to this point
            if (x === 0) {
              ctx.moveTo(x * resolution, y * resolution + waveHeight);
            } else {
              ctx.lineTo(x * resolution, y * resolution + waveHeight);
            }
          }
          
          ctx.stroke();
        }
        
        // Add ripple effects
        if (audioFeatures && Math.random() < 0.05 * (audioFeatures.energy || 0.5)) {
          // Create ripple
          const rippleX = Math.random() * width;
          const rippleY = Math.random() * height * 0.7 + height * 0.3; // Bottom 70%
          
          // Draw ripple
          ctx.beginPath();
          ctx.arc(rippleX, rippleY, 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.fill();
          
          // Add glow
          ctx.beginPath();
          ctx.arc(rippleX, rippleY, 15, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.fill();
        }
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    }
    
    // Starfield visualization
    function startStarfieldVisualization() {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Star properties
      const starCount = highQualityMode ? 1000 : 500;
      const stars = [];
      
      // Center of the canvas
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Create stars
      for (let i = 0; i < starCount; i++) {
        // Random position in 3D space
        const z = Math.random() * 1000;
        
        stars.push({
          x: (Math.random() * width - centerX) * (z / 500),
          y: (Math.random() * height - centerY) * (z / 500),
          z: z,
          size: Math.random() * 2 + 1,
          color: Math.random() > 0.5 ? 'white' : getStarColor()
        });
      }
      
      // Get star color based on theme
      function getStarColor() {
        switch (colorTheme) {
          case 'spotify':
            return '#1DB954';
          case 'sunset':
            return '#FF8C00';
          case 'ocean':
            return '#00C6FF';
          case 'purple':
            return '#8E2DE2';
          default:
            return '#1DB954';
        }
      }
      
      // Animation function
      function animate() {
        // Semi-transparent background for trails
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, width, height);
        
        // Calculate speed based on audio features and motion speed setting
        let speed = 2 * (motionSpeed / 50);
        let warpFactor = 1;
        
        // Adjust speed based on audio features
        if (audioFeatures) {
          const energy = audioFeatures.energy || 0.5;
          const tempo = audioFeatures.tempo || 120;
          
          // Normalize tempo around 120 BPM
          const tempoFactor = tempo / 120;
          
          // Calculate speed based on energy and tempo
          speed *= energy * tempoFactor;
          
          // Create warp effect on high energy sections
          warpFactor = 1 + energy * (bassBoost / 100);
        }
        
        // Update and draw stars
        for (let i = 0; i < stars.length; i++) {
          const star = stars[i];
          
          // Move star closer (decrease z)
          star.z -= speed;
          
          // Reset star if it goes behind camera or too far
          if (star.z <= 0 || star.z > 1000) {
            star.z = 1000;
            star.x = (Math.random() * width - centerX) * 2;
            star.y = (Math.random() * height - centerY) * 2;
            star.color = Math.random() > 0.5 ? 'white' : getStarColor();
          }
          
          // Calculate screen position
          const screenX = centerX + star.x * (1000 / star.z) * warpFactor;
          const screenY = centerY + star.y * (1000 / star.z) * warpFactor;
          
          // Calculate previous position for trail
          const prevZ = star.z + speed;
          const prevScreenX = centerX + star.x * (1000 / prevZ) * warpFactor;
          const prevScreenY = centerY + star.y * (1000 / prevZ) * warpFactor;
          
          // Calculate star size based on z position
          const scaledSize = star.size * (1000 / star.z) * (sensitivity / 50);
          
          // Calculate opacity based on z position
          const opacity = Math.min(1, (1000 - star.z) / 500);
          
          // Draw star trail
          ctx.beginPath();
          ctx.moveTo(prevScreenX, prevScreenY);
          ctx.lineTo(screenX, screenY);
          ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
          ctx.lineWidth = scaledSize / 2;
          ctx.stroke();
          
          // Draw star
          ctx.beginPath();
          ctx.arc(screenX, screenY, scaledSize, 0, Math.PI * 2);
          ctx.fillStyle = star.color === 'white' 
            ? `rgba(255, 255, 255, ${opacity})` 
            : `rgba(${parseInt(star.color.slice(1, 3), 16)}, ${parseInt(star.color.slice(3, 5), 16)}, ${parseInt(star.color.slice(5, 7), 16)}, ${opacity})`;
          ctx.fill();
        }
        
        // Add warp effect during high energy
        if (audioFeatures && audioFeatures.energy > 0.7) {
          // Create radial gradient for warp effect
          const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, width);
          
          // Get color based on theme
          let primaryColor;
          switch (colorTheme) {
            case 'spotify':
              primaryColor = '#1DB954';
              break;
            case 'sunset':
              primaryColor = '#FF8C00';
              break;
            case 'ocean':
              primaryColor = '#0072FF';
              break;
            case 'purple':
              primaryColor = '#8E2DE2';
              break;
            default:
              primaryColor = '#1DB954';
          }
          
          gradient.addColorStop(0, `rgba(${parseInt(primaryColor.slice(1, 3), 16)}, ${parseInt(primaryColor.slice(3, 5), 16)}, ${parseInt(primaryColor.slice(5, 7), 16)}, 0.1)`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          
          // Draw warp effect
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
        }
        
        // Continue animation
        window.animationFrame = requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    }
    
    // Format time in milliseconds to MM:SS
    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Play/Pause button click handler
    playPauseButton.addEventListener('click', function() {
      if (player) {
        player.togglePlay().then(() => {
          isPlaying = !isPlaying;
          updatePlayPauseButton(!isPlaying);
        });
      }
    });
    
    // Previous button click handler
    prevButton.addEventListener('click', function() {
      if (player) {
        player.previousTrack().then(() => {
          // The state change event will handle UI updates
        }).catch(error => {
          console.error('Error skipping to previous track:', error);
        });
      }
    });
    
    // Next button click handler
    nextButton.addEventListener('click', function() {
      if (player) {
        player.nextTrack().then(() => {
          // The state change event will handle UI updates
        }).catch(error => {
          console.error('Error skipping to next track:', error);
        });
      }
    });
    
    // Progress bar click handler
    document.querySelector('.progress-bar').addEventListener('click', function(e) {
      if (!currentTrack) return;
      
      const rect = this.getBoundingClientRect();
      const clickPosition = (e.clientX - rect.left) / rect.width;
      const seekPosition = Math.floor(currentTrack.duration_ms * clickPosition);
      
      // Update UI immediately for better responsiveness
      currentTimeElement.textContent = formatTime(seekPosition);
      const newProgress = (seekPosition / currentTrack.duration_ms) * 100;
      progressBar.style.width = `${newProgress}%`;
      document.querySelector('.progress-handle').style.left = `${newProgress}%`;
      
      fetch(`${apiEndpoint}/me/player/seek?position_ms=${seekPosition}&device_id=${deviceId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }).catch(error => {
        console.error('Error seeking to position:', error);
      });
    });
    
    // Visualization mode switching
    let currentVisualizationMode = 'particles';
    
    document.querySelectorAll('.viz-button').forEach(button => {
      button.addEventListener('click', function() {
        // Remove active class from all buttons
        document.querySelectorAll('.viz-button').forEach(btn => {
          btn.classList.remove('active');
        });
        
        // Add active class to clicked button
        this.classList.add('active');
        
        // Set current visualization mode
        currentVisualizationMode = this.dataset.viz;
        
        // Update visualization
        updateVisualizationMode(currentVisualizationMode);
      });
    });
    
    function updateVisualizationMode(mode) {
      console.log('Switching visualization mode to:', mode);
      
      // Reset canvas
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Stop any existing animation loops
      if (window.animationFrame) {
        cancelAnimationFrame(window.animationFrame);
      }
      
      // Start the selected visualization
      switch(mode) {
        case 'bars':
          initBarsVisualization();
          break;
        case 'circular':
          initCircularVisualization();
          break;
        case 'particles':
          initParticlesVisualization();
          break;
        case 'waveform':
          initWaveformVisualization();
          break;
        default:
          initParticlesVisualization();
      }
    }
    
    // Global variables for visualizations
    let particles = [];
    let audioData = [];
    let analyser;
    
    // Initialize canvas
    function initCanvas() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Re-apply current visualization when canvas is resized
        if (currentVisualizationMode) {
          updateVisualizationMode(currentVisualizationMode);
        }
      }
      
      // Enable high DPI rendering for sharper visuals
      function setupHighDPI() {
        const dpr = window.devicePixelRatio || 1;
        
        // Set display size (css pixels)
        const displayWidth = window.innerWidth;
        const displayHeight = window.innerHeight;
        
        // Set actual size in memory (scaled to account for extra pixel density)
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        
        // Scale context to ensure correct drawing operations
        ctx.scale(dpr, dpr);
        
        // Set CSS size
        canvas.style.width = `${displayWidth}px`;
        canvas.style.height = `${displayHeight}px`;
      }
      
      // Initial setup
      if (highQualityMode) {
        setupHighDPI();
      } else {
        resizeCanvas();
      }
      
      // Handle resize events
      window.addEventListener('resize', () => {
        if (highQualityMode) {
          setupHighDPI();
        } else {
          resizeCanvas();
        }
      });
      
      // Start with spectrum visualization by default
      updateVisualizationMode('spectrum');
    }
    
    // Particles Visualization
    function initParticlesVisualization() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Reset particles array
      particles = [];
      const particleCount = 150;
      
      // Create particles
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 2 + 1,
          color: `hsla(${Math.random() * 40 + 120}, 80%, 60%, ${Math.random() * 0.5 + 0.1})`,
          speedX: (Math.random() - 0.5) * 0.5,
          speedY: (Math.random() - 0.5) * 0.5
        });
      }
      
      // Animation function
      function animateParticles() {
        window.animationFrame = requestAnimationFrame(animateParticles);
        
        // Clear canvas with semi-transparent background for trail effect
        ctx.fillStyle = 'rgba(5, 5, 5, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Update and draw particles
        particles.forEach((particle, index) => {
          // Update position
          particle.x += particle.speedX;
          particle.y += particle.speedY;
          
          // Bounce off edges
          if (particle.x < 0 || particle.x > canvas.width) {
            particle.speedX *= -1;
          }
          
          if (particle.y < 0 || particle.y > canvas.height) {
            particle.speedY *= -1;
          }
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          ctx.fillStyle = particle.color;
          ctx.fill();
          
          // Connect particles
          for (let j = index + 1; j < particles.length; j++) {
            const dx = particle.x - particles[j].x;
            const dy = particle.y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              ctx.beginPath();
              ctx.strokeStyle = `hsla(${parseInt(particle.color.split(',')[0].split('(')[1])}, 80%, 60%, ${0.1 * (1 - distance / 100)})`;
              ctx.lineWidth = 0.5;
              ctx.moveTo(particle.x, particle.y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }
        });
      }
      
      // Start animation
      animateParticles();
    }
    
    // Bars Visualization
    function initBarsVisualization() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Create fake audio data for visualization
      audioData = [];
      for (let i = 0; i < 64; i++) {
        audioData.push(Math.random() * 0.5);
      }
      
      // Animation function
      function animateBars() {
        window.animationFrame = requestAnimationFrame(animateBars);
        
        // Clear canvas
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Update fake audio data
        for (let i = 0; i < audioData.length; i++) {
          // Gradually move towards a new random value
          const target = Math.random() * 0.8;
          audioData[i] = audioData[i] * 0.9 + target * 0.1;
        }
        
        // Draw bars
        const barWidth = canvas.width / audioData.length;
        const centerY = canvas.height / 2;
        
        for (let i = 0; i < audioData.length; i++) {
          const barHeight = audioData[i] * canvas.height * 0.8;
          const x = i * barWidth;
          
          // Calculate hue based on frequency (higher frequencies = warmer colors)
          const hue = 120 - (i / audioData.length) * 120;
          
          // Draw mirrored bars
          ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
          
          // Top bar
          ctx.fillRect(x, centerY - barHeight, barWidth - 2, barHeight);
          
          // Bottom bar (mirrored)
          ctx.fillRect(x, centerY, barWidth - 2, barHeight);
        }
      }
      
      // Start animation
      animateBars();
    }
    
    // Circular Visualization
    function initCircularVisualization() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Create fake audio data for visualization
      audioData = [];
      for (let i = 0; i < 128; i++) {
        audioData.push(Math.random() * 0.5);
      }
      
      // Animation variables
      let rotation = 0;
      
      // Animation function
      function animateCircular() {
        window.animationFrame = requestAnimationFrame(animateCircular);
        
        // Clear canvas
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Update fake audio data
        for (let i = 0; i < audioData.length; i++) {
          // Gradually move towards a new random value
          const target = Math.random() * 0.8;
          audioData[i] = audioData[i] * 0.9 + target * 0.1;
        }
        
        // Center of the canvas
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Radius of the circle
        const radius = Math.min(canvas.width, canvas.height) * 0.3;
        
        // Draw circular visualization
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        
        for (let i = 0; i < audioData.length; i++) {
          const angle = (i / audioData.length) * Math.PI * 2;
          const barHeight = audioData[i] * radius;
          
          // Calculate hue based on angle
          const hue = (angle / (Math.PI * 2)) * 360;
          
          ctx.save();
          ctx.rotate(angle);
          
          // Draw bar
          ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
          ctx.fillRect(0, radius - barHeight, 3, barHeight);
          
          ctx.restore();
        }
        
        ctx.restore();
        
        // Increment rotation
        rotation += 0.005;
      }
      
      // Start animation
      animateCircular();
    }
    
    // Waveform Visualization
    function initWaveformVisualization() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Create fake audio data for visualization
      audioData = [];
      for (let i = 0; i < 128; i++) {
        audioData.push(Math.sin(i * 0.1) * 0.5 + 0.5);
      }
      
      // Animation variables
      let time = 0;
      
      // Animation function
      function animateWaveform() {
        window.animationFrame = requestAnimationFrame(animateWaveform);
        
        // Clear canvas
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Update fake audio data
        for (let i = 0; i < audioData.length; i++) {
          audioData[i] = Math.sin((i * 0.1) + time) * 0.3 + 0.5 + Math.random() * 0.1;
        }
        
        // Center of the canvas
        const centerY = canvas.height / 2;
        
        // Draw waveform
        ctx.beginPath();
        ctx.moveTo(0, centerY + (audioData[0] - 0.5) * canvas.height * 0.8);
        
        for (let i = 1; i < audioData.length; i++) {
          const x = (i / audioData.length) * canvas.width;
          const y = centerY + (audioData[i] - 0.5) * canvas.height * 0.8;
          ctx.lineTo(x, y);
        }
        
        // Create gradient
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, 'hsla(240, 80%, 60%, 0.8)');
        gradient.addColorStop(0.5, 'hsla(180, 80%, 60%, 0.8)');
        gradient.addColorStop(1, 'hsla(120, 80%, 60%, 0.8)');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Fill area under the curve
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        
        const fillGradient = ctx.createLinearGradient(0, centerY, 0, canvas.height);
        fillGradient.addColorStop(0, 'hsla(180, 80%, 60%, 0.2)');
        fillGradient.addColorStop(1, 'hsla(180, 80%, 60%, 0.0)');
        
        ctx.fillStyle = fillGradient;
        ctx.fill();
        
        // Increment time
        time += 0.05;
      }
      
      // Start animation
      animateWaveform();
    }
    
    // Initialize custom cursor
    function initCustomCursor() {
      // Only on desktop
      if (window.innerWidth <= 768) return;
      
      document.addEventListener('mousemove', e => {
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
        
        cursorDot.style.left = e.clientX + 'px';
        cursorDot.style.top = e.clientY + 'px';
      });
      
      // Hover effect on interactive elements
      const interactiveElements = document.querySelectorAll('button, a, .feature');
      
      interactiveElements.forEach(el => {
        el.addEventListener('mouseenter', () => {
          cursor.style.width = '60px';
          cursor.style.height = '60px';
          cursor.style.borderColor = 'var(--accent)';
        });
        
        el.addEventListener('mouseleave', () => {
          cursor.style.width = '40px';
          cursor.style.height = '40px';
          cursor.style.borderColor = 'var(--accent)';
        });
      });
    }
    
    // Initialize visualizer settings
    function initializeVisualizerSettings() {
      // Set up sidebar toggle
      sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
      });
      
      // Set up settings toggle
      settingsToggle.addEventListener('click', () => {
        sidebar.classList.remove('collapsed');
      });
      
      // Set up fullscreen button
      fullscreenButton.addEventListener('click', toggleFullscreen);
      
      // Set up disconnect button
      disconnectButton.addEventListener('click', () => {
        localStorage.removeItem('spotify_access_token');
        localStorage.removeItem('spotify_refresh_token');
        localStorage.removeItem('token_expiry');
        localStorage.removeItem('visualization_settings');
        window.location.reload();
      });
      
      // Set up visualization mode buttons
      vizOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Remove active class from all options
          vizOptions.forEach(opt => opt.classList.remove('active'));
          
          // Add active class to clicked option
          option.classList.add('active');
          
          // Set current visualization mode
          currentVisualizationMode = option.dataset.viz;
          currentVizModeElement.textContent = option.querySelector('span').textContent;
          
          // Save to localStorage
          saveVisualizationSettings();
          
          // Update visualization
          updateVisualizationMode(currentVisualizationMode);
        });
      });
      
      // Set up sensitivity slider
      sensitivitySlider.addEventListener('input', () => {
        sensitivity = parseInt(sensitivitySlider.value);
        sensitivityValue.textContent = `${sensitivity}%`;
        saveVisualizationSettings();
      });
      
      // Set up bass slider
      bassSlider.addEventListener('input', () => {
        bassBoost = parseInt(bassSlider.value);
        bassValue.textContent = `${bassBoost}%`;
        saveVisualizationSettings();
      });
      
      // Set up speed slider
      speedSlider.addEventListener('input', () => {
        motionSpeed = parseInt(speedSlider.value);
        speedValue.textContent = `${motionSpeed}%`;
        saveVisualizationSettings();
      });
      
      // Set up quality toggle
      qualityToggle.addEventListener('change', () => {
        highQualityMode = qualityToggle.checked;
        saveVisualizationSettings();
        updateVisualizationQuality();
      });
      
      // Set up fullscreen toggle
      fullscreenToggle.addEventListener('change', () => {
        if (fullscreenToggle.checked) {
          enterFullscreen();
        } else {
          exitFullscreen();
        }
        saveVisualizationSettings();
      });
      
      // Set up FPS toggle
      fpsToggle.addEventListener('change', () => {
        showFps = fpsToggle.checked;
        fpsCounterElement.style.display = showFps ? 'block' : 'none';
        saveVisualizationSettings();
      });
      
      // Set up color theme options
      colorOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Remove active class from all options
          colorOptions.forEach(opt => opt.classList.remove('active'));
          
          // Add active class to clicked option
          option.classList.add('active');
          
          // Set color theme
          colorTheme = option.dataset.theme;
          saveVisualizationSettings();
          updateColorTheme();
        });
      });
      
      // Load saved settings
      loadVisualizationSettings();
      
      // Start the visualization
      updateVisualizationMode(currentVisualizationMode);
      
      // Start FPS counter
      updateFpsCounter();
    }
    
    // Save visualization settings to localStorage
    function saveVisualizationSettings() {
      const settings = {
        visualizationMode: currentVisualizationMode,
        sensitivity: sensitivity,
        bassBoost: bassBoost,
        motionSpeed: motionSpeed,
        colorTheme: colorTheme,
        highQualityMode: highQualityMode,
        showFps: showFps,
        isFullscreen: isFullscreen
      };
      
      localStorage.setItem('visualization_settings', JSON.stringify(settings));
    }
    
    // Load visualization settings from localStorage
    function loadVisualizationSettings() {
      const savedSettings = localStorage.getItem('visualization_settings');
      
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        
        // Apply saved settings
        currentVisualizationMode = settings.visualizationMode || 'spectrum';
        sensitivity = settings.sensitivity || 50;
        bassBoost = settings.bassBoost || 30;
        motionSpeed = settings.motionSpeed || 60;
        colorTheme = settings.colorTheme || 'spotify';
        highQualityMode = settings.highQualityMode || false;
        showFps = settings.showFps || false;
        isFullscreen = settings.isFullscreen || false;
        
        // Update UI to reflect saved settings
        vizOptions.forEach(option => {
          if (option.dataset.viz === currentVisualizationMode) {
            option.classList.add('active');
            currentVizModeElement.textContent = option.querySelector('span').textContent;
          } else {
            option.classList.remove('active');
          }
        });
        
        sensitivitySlider.value = sensitivity;
        sensitivityValue.textContent = `${sensitivity}%`;
        
        bassSlider.value = bassBoost;
        bassValue.textContent = `${bassBoost}%`;
        
        speedSlider.value = motionSpeed;
        speedValue.textContent = `${motionSpeed}%`;
        
        qualityToggle.checked = highQualityMode;
        fullscreenToggle.checked = isFullscreen;
        fpsToggle.checked = showFps;
        
        colorOptions.forEach(option => {
          if (option.dataset.theme === colorTheme) {
            option.classList.add('active');
          } else {
            option.classList.remove('active');
          }
        });
        
        // Apply settings
        fpsCounterElement.style.display = showFps ? 'block' : 'none';
        updateVisualizationQuality();
        updateColorTheme();
        
        if (isFullscreen) {
          enterFullscreen();
        }
      }
    }
    
    // Update visualization quality
    function updateVisualizationQuality() {
      // Adjust particle count or other quality settings based on highQualityMode
      if (highQualityMode) {
        // High quality settings
        console.log('High quality mode enabled');
      } else {
        // Standard quality settings
        console.log('Standard quality mode enabled');
      }
    }
    
    // Update color theme
    function updateColorTheme() {
      // Apply color theme to visualizations
      console.log('Color theme updated to:', colorTheme);
      
      // Update CSS variables
      let primaryColor, secondaryColor;
      
      switch (colorTheme) {
        case 'spotify':
          primaryColor = '#1DB954';
          secondaryColor = '#191414';
          break;
        case 'sunset':
          primaryColor = '#FF8C00';
          secondaryColor = '#FF2D00';
          break;
        case 'ocean':
          primaryColor = '#0072FF';
          secondaryColor = '#00C6FF';
          break;
        case 'purple':
          primaryColor = '#8E2DE2';
          secondaryColor = '#4A00E0';
          break;
        default:
          primaryColor = '#1DB954';
          secondaryColor = '#191414';
      }
      
      document.documentElement.style.setProperty('--accent', primaryColor);
      document.documentElement.style.setProperty('--accent-hover', primaryColor);
    }
    
    // Toggle fullscreen
    function toggleFullscreen() {
      if (!isFullscreen) {
        enterFullscreen();
      } else {
        exitFullscreen();
      }
    }
    
    // Enter fullscreen
    function enterFullscreen() {
      const element = document.documentElement;
      
      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
      
      isFullscreen = true;
      fullscreenToggle.checked = true;
      saveVisualizationSettings();
    }
    
    // Exit fullscreen
    function exitFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
      
      isFullscreen = false;
      fullscreenToggle.checked = false;
      saveVisualizationSettings();
    }
    
    // Update FPS counter
    function updateFpsCounter() {
      const now = performance.now();
      frameCount++;
      
      if (now - fpsTime >= 1000) {
        fps = Math.round((frameCount * 1000) / (now - fpsTime));
        fpsCounterElement.textContent = `${fps} FPS`;
        fpsTime = now;
        frameCount = 0;
      }
      
      requestAnimationFrame(updateFpsCounter);
    }
    
    // Initialize typing animation
    function initTypingAnimation() {
      const words = ['Spotify', 'music', 'sound', 'audio'];
      let wordIndex = 0;
      let charIndex = 0;
      let isDeleting = false;
      let isWaiting = false;
      
      function type() {
        const currentWord = words[wordIndex];
        
        if (isWaiting) {
          setTimeout(() => {
            isWaiting = false;
            type();
          }, 1500);
          return;
        }
        
        if (isDeleting) {
          // Remove a character
          typingText.textContent = currentWord.substring(0, charIndex - 1);
          charIndex--;
          
          // If all characters are deleted
          if (charIndex === 0) {
            isDeleting = false;
            wordIndex = (wordIndex + 1) % words.length;
          }
        } else {
          // Add a character
          typingText.textContent = currentWord.substring(0, charIndex + 1);
          charIndex++;
          
          // If word is complete
          if (charIndex === currentWord.length) {
            isDeleting = true;
            isWaiting = true;
          }
        }
        
        // Speed based on whether deleting or typing
        const typingSpeed = isDeleting ? 100 : 200;
        
        setTimeout(type, typingSpeed);
      }
      
      // Start typing animation
      setTimeout(type, 1000);
    }
  </script>
</body>
</html>